<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="document_processor_title">Document Processor - DropShare</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #333;
            line-height: 1.6;
        }

        .header {
            background: white;
            border-bottom: 1px solid #e5e7eb;
            padding: 12px 0;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 20px;
            font-weight: bold;
            color: #3367d6;
            text-decoration: none;
        }

        .nav-links {
            display: flex;
            gap: 16px;
        }
        
        .nav-links a {
            color: #6b7280;
            text-decoration: none;
            font-weight: 500;
            font-size: 14px;
            padding: 6px 12px;
            border-radius: 6px;
            transition: all 0.2s ease;
        }
        
        .nav-links a:hover {
            color: #3367d6;
            background: #f3f4f6;
        }
        
        .nav-links a.active {
            color: #3367d6;
            background: #e3f2fd;
            font-weight: 600;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .page-title {
            font-size: 32px;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 8px;
            text-align: center;
        }

        .page-subtitle {
            font-size: 16px;
            color: #6b7280;
            text-align: center;
            margin-bottom: 40px;
        }
        
        
        .processor-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 30px;
            margin-bottom: 30px;
        }
        
        .upload-area {
            border: 3px dashed #d1d5db;
            border-radius: 12px;
            padding: 60px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f9fafb;
            margin-bottom: 30px;
        }
        
        .upload-area:hover, .upload-area.dragover {
            border-color: #3367d6;
            background: #eff6ff;
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 16px;
            color: #9ca3af;
        }

        .upload-text {
            font-size: 18px;
            color: #374151;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .upload-hint {
            font-size: 14px;
            color: #6b7280;
        }

        #fileInput {
            display: none;
        }
        
        .processing-workspace {
            display: none;
        }
        
        .tabs {
            display: flex;
            gap: 0;
            margin-bottom: 20px;
            background: #f3f4f6;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .tab {
            flex: 1;
            padding: 12px 20px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
            color: #6b7280;
        }
        
        .tab.active {
            background: #3367d6;
            color: white;
        }
        
        .tab-content {
            display: none;
            padding: 20px;
            background: #f9fafb;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .document-preview {
            width: 100%;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            max-height: 500px;
            border: 1px solid #e5e7eb;
        }
        
        .preview-header {
            padding: 15px 20px;
            background: #3367d6;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .document-info h4 {
            margin: 0 0 4px 0;
            font-size: 16px;
        }
        
        .document-info p {
            margin: 0;
            font-size: 12px;
            opacity: 0.8;
        }
        
        .preview-controls {
            padding: 15px 20px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            gap: 15px;
            background: #f9fafb;
        }
        
        .preview-area {
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .page-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .page-btn {
            padding: 6px 12px;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        .page-btn:hover {
            background: #3367d6;
            color: white;
            border-color: #3367d6;
        }
        
        .page-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .page-input {
            width: 60px;
            padding: 4px 8px;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            text-align: center;
            font-size: 12px;
        }
        
        .tool-group {
            background: #f9fafb;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            margin-bottom: 15px;
        }
        
        .tool-group h4 {
            margin-bottom: 15px;
            color: #374151;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }
        
        .settings-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        
        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .setting-item label {
            font-weight: 500;
            color: #374151;
            font-size: 14px;
        }
        
        .setting-item input, .setting-item select {
            padding: 8px 12px;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            background: white;
            color: #374151;
            font-size: 14px;
        }
        
        .range-input {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .range-input input[type="range"] {
            flex: 1;
        }
        
        .range-value {
            min-width: 40px;
            text-align: center;
            font-weight: 500;
            color: #3367d6;
        }
        
        .page-range {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }
        
        .page-range input {
            width: 60px;
        }
        
        .process-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 30px 0;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 16px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: #3367d6;
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            background: #2563eb;
            transform: translateY(-1px);
        }
        
        .btn-primary:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-secondary {
            background: #6b7280;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #4b5563;
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn-success:hover {
            background: #059669;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 15px 0;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .text-extraction-result {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 13px;
            line-height: 1.5;
        }
        
        .progress-section {
            display: none;
            margin: 20px 0;
            padding: 20px;
            background: #f9fafb;
            border-radius: 8px;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #f3f4f6;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: #3367d6;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .result-section {
            display: none;
            margin-top: 30px;
            padding: 20px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background: #f0f9ff;
            border: 1px solid #bae6fd;
        }
        
        .result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-item {
            text-align: center;
            padding: 15px;
            background: #f9fafb;
            border-radius: 8px;
        }
        
        .stat-label {
            display: block;
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 4px;
            text-transform: uppercase;
            font-weight: 500;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: 600;
            color: #374151;
        }
        
        @media (max-width: 768px) {
            .nav-links {
                display: none;
            }

            .container {
                padding: 20px 16px;
            }

            .processor-card {
                padding: 20px;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .settings-panel {
                grid-template-columns: 1fr;
            }
            
            .process-actions {
                flex-direction: column;
            }
            
            .process-actions .btn {
                width: 100%;
            }
            
            .result-stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>

    <link rel="stylesheet" href="share-integration.css">
    <link rel="stylesheet" href="device-selector.css">
    <script src="/locales/i18n.js"></script>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-container">
            <a href="/" class="logo">
                üìÑ DropShare
            </a>
            <nav class="nav-links">
                <a href="index.html">Home</a>
                <a href="share.html">Transfer</a>
                <a href="share.html#rooms">Rooms</a>
                <a href="image-tools.html">Images</a>
                <a href="audio-tools.html">Audio</a>
                <a href="video-tools.html">Video</a>
                <a href="document-tools.html" class="active">Files</a>
            </nav>
        </div>
    </header>
    
    <div class="container">
        <!-- Top-left return button -->
        <div style="margin-bottom: 20px;">
            <a href="document-tools.html" style="display: inline-flex; align-items: center; gap: 8px; padding: 8px 16px; color: #3367d6; text-decoration: none; border: 1px solid #3367d6; border-radius: 8px; transition: all 0.3s ease; font-size: 14px;" onmouseover="this.style.background='#3367d6'; this.style.color='white'" onmouseout="this.style.background=''; this.style.color='#3367d6'">
                ‚Üê back
            </a>
        </div>
        
        <h1 class="page-title">üìÑ Document Processor</h1>
        <p class="page-subtitle">Process, convert, split, merge, and extract text from documents</p>

        <div class="processor-card">
            <!-- Upload Area -->
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">üìÑ</div>
                <div class="upload-text">Drop documents here or click to select</div>
                <div class="upload-hint">Supports PDF, DOCX, TXT, RTF, HTML formats</div>
                <input type="file" id="fileInput" accept=".pdf,.docx,.txt,.rtf,.html,.doc">
                <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()" style="margin-top: 15px;">
                    Select Document Files
                </button>
            </div>
        
        <div class="processing-workspace" id="processingWorkspace">
            <div class="document-preview">
                <div class="preview-header">
                    <div class="document-info">
                        <h4 id="documentFileName">No file selected</h4>
                        <p id="documentFileInfo">-</p>
                    </div>
                    <div class="document-actions">
                        <span id="documentPageInfo">Page: - / -</span>
                    </div>
                </div>
                <div class="preview-controls">
                    <div class="page-controls">
                        <button class="page-btn" id="firstPageBtn">‚èÆÔ∏è</button>
                        <button class="page-btn" id="prevPageBtn">‚óÄÔ∏è</button>
                        <input type="number" id="currentPageInput" class="page-input" min="1" value="1">
                        <button class="page-btn" id="nextPageBtn">‚ñ∂Ô∏è</button>
                        <button class="page-btn" id="lastPageBtn">‚è≠Ô∏è</button>
                    </div>
                    <div class="zoom-controls">
                        <button class="page-btn" id="zoomOutBtn">üîç-</button>
                        <span id="zoomLevel">100%</span>
                        <button class="page-btn" id="zoomInBtn">üîç+</button>
                    </div>
                </div>
                <div class="preview-area" id="previewArea">
                    <p style="text-align: center; color: #6b7280; margin: 40px 0;">Select a document file to preview</p>
                </div>
            </div>
            
            <div class="tabs">
                <button class="tab active" data-tab="extract">Text Extract</button>
                <button class="tab" data-tab="split">Split Document</button>
                <button class="tab" data-tab="merge">Merge Documents</button>
                <button class="tab" data-tab="convert">Format Convert</button>
            </div>
            
            <!-- ÊñáÊú¨ÊèêÂèñ -->
            <div class="tab-content active" id="extractTab">
                <div class="tool-group">
                    <h4>üìù Text Extraction Settings</h4>
                    <div class="page-range">
                        <label>Extract pages:</label>
                        <input type="number" id="extractStartPage" placeholder="Start page" min="1" value="1">
                        <span>to</span>
                        <input type="number" id="extractEndPage" placeholder="End page" min="1">
                        <button class="page-btn" id="extractAllPagesBtn">All Pages</button>
                    </div>
                    
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="preserveFormatting" checked>
                            <label for="preserveFormatting">Preserve formatting</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="extractImages">
                            <label for="extractImages">Extract image links</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="removeBlankLines">
                            <label for="removeBlankLines">Remove blank lines</label>
                        </div>
                    </div>
                </div>
                
                <div id="extractedTextArea" class="text-extraction-result" style="display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <strong>Extracted text:</strong>
                        <button class="page-btn" id="copyTextBtn">Copy Text</button>
                    </div>
                    <div id="extractedText"></div>
                </div>
            </div>
            
            <!-- Document Split -->
            <div class="tab-content" id="splitTab">
                <div class="tool-group">
                    <h4>‚úÇÔ∏è Document Split Settings</h4>
                    <div class="settings-panel">
                        <div class="setting-item">
                            <label>Split method:</label>
                            <select id="splitMethod">
                                <option value="pages">By page range</option>
                                <option value="interval">By interval pages</option>
                                <option value="bookmarks">By bookmarks</option>
                            </select>
                        </div>
                        
                        <div class="setting-item" id="intervalSetting">
                            <label>Pages per file:</label>
                            <input type="number" id="splitInterval" value="10" min="1">
                        </div>
                    </div>
                    
                    <div id="pageRangesSetting" style="display: none;">
                        <label>Page ranges (comma separated, e.g., 1-5, 10-15, 20):</label>
                        <input type="text" id="pageRanges" placeholder="1-5, 10-15, 20" style="width: 100%; margin-top: 8px;">
                    </div>
                </div>
            </div>
            
            <!-- Document Merge -->
            <div class="tab-content" id="mergeTab">
                <div class="tool-group">
                    <h4>üîó Document Merge Settings</h4>
                    <p style="margin-bottom: 15px; color: #6b7280;">
                        Merge multiple PDF documents into one. Please upload multiple files.
                    </p>
                    
                    <div style="margin: 15px 0;">
                        <input type="file" id="mergeFilesInput" accept=".pdf" multiple style="display: none;">
                        <button class="btn btn-secondary" onclick="document.getElementById('mergeFilesInput').click()">
                            Select Documents to Merge
                        </button>
                    </div>
                    
                    <div id="mergeFilesList" style="margin: 15px 0;"></div>
                    
                    <div class="checkbox-item">
                        <input type="checkbox" id="addBookmarks" checked>
                        <label for="addBookmarks">Add bookmarks for each document</label>
                    </div>
                </div>
            </div>
            
            <!-- Format Convert -->
            <div class="tab-content" id="convertTab">
                <div class="tool-group">
                    <h4>üîÑ Format Convert Settings</h4>
                    <div class="settings-panel">
                        <div class="setting-item">
                            <label>Output format:</label>
                            <select id="outputFormat">
                                <option value="pdf">PDF</option>
                                <option value="docx">Word Document (.docx)</option>
                                <option value="txt">Plain Text (.txt)</option>
                                <option value="html">HTML Webpage</option>
                                <option value="rtf">RTF Document</option>
                                <option value="images">Images (JPG/PNG)</option>
                            </select>
                        </div>
                        
                        <div class="setting-item" id="imageQualitySetting" style="display: none;">
                            <label>Image quality:</label>
                            <div class="range-input">
                                <input type="range" id="imageQuality" min="50" max="100" value="90">
                                <span class="range-value" id="imageQualityValue">90%</span>
                            </div>
                        </div>
                        
                        <div class="setting-item" id="imageDpiSetting" style="display: none;">
                            <label>Image DPI:</label>
                            <select id="imageDpi">
                                <option value="72">72 DPI (Web)</option>
                                <option value="150" selected>150 DPI (Standard)</option>
                                <option value="300">300 DPI (High Quality)</option>
                                <option value="600">600 DPI (Print)</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="process-actions">
                <button class="btn btn-primary" id="processBtn" disabled>Start Processing</button>
                <button class="btn btn-secondary" id="resetBtn">Reset Settings</button>
                <button class="btn btn-secondary" id="newFileBtn">Select New Document</button>
            </div>
            
            <div class="progress-section" id="progressSection">
                <h4>Processing Progress:</h4>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div id="progressText">Ready to process...</div>
            </div>
            
            <div class="result-section" id="resultSection">
                <h3>üéâ Processing Results</h3>
                
                <div class="result-stats">
                    <div class="stat-item">
                        <span class="stat-label">Original Size</span>
                        <span class="stat-value" id="originalFileSize">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Processed Size</span>
                        <span class="stat-value" id="resultFileSize">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Page Count</span>
                        <span class="stat-value" id="pageCount">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Processing Time</span>
                        <span class="stat-value" id="processingTime">-</span>
                    </div>
                </div>
                
                <div id="resultFilesList"></div>
                
                <div class="process-actions">
                    <button class="btn btn-success" id="downloadAllBtn">üì• Download All Files</button>
                    <button class="btn btn-secondary" id="shareAllBtn">üì§ Share All Files</button>
                    <button class="btn btn-secondary" id="processAnotherBtn">üîÑ Process Another Document</button>
                </div>
            </div>
        </div>
    </div>

    <!-- PDF.js Library -->
    <script src="https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
    <script>
        // PDF.js worker setup
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js';
        }
    </script>

    <script>
        // ÂõΩÈôÖÂåñËæÖÂä©ÂáΩÊï∞
        function getI18nText(key) {
            if (window.DROPSHARE_I18N && typeof 
            }
            return null;
        }

        class DocumentProcessor {
            constructor() {
                this.documentFile = null;
                this.currentPage = 1;
                this.totalPages = 0;
                this.zoomLevel = 100;
                this.currentTab = 'extract';
                this.processedFiles = [];
                this.mergeFiles = [];
                this.documentContent = null;
                
                this.init();
            }
            
            init() {
                this.bindEvents();
            }
            
            bindEvents() {
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                
                // ÊãñÊãΩ‰∏ä‰º†
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.loadDocument(files[0]);
                    }
                });
                
                // Êñá‰ª∂ÈÄâÊã©
                fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.loadDocument(e.target.files[0]);
                    }
                });
                
                // Ê†áÁ≠æÂàáÊç¢
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', () => this.switchTab(tab.dataset.tab));
                });
                
                // È°µÈù¢ÂØºËà™
                document.getElementById('firstPageBtn').addEventListener('click', () => this.goToPage(1));
                document.getElementById('prevPageBtn').addEventListener('click', () => this.goToPage(this.currentPage - 1));
                document.getElementById('nextPageBtn').addEventListener('click', () => this.goToPage(this.currentPage + 1));
                document.getElementById('lastPageBtn').addEventListener('click', () => this.goToPage(this.totalPages));
                document.getElementById('currentPageInput').addEventListener('change', (e) => this.goToPage(parseInt(e.target.value)));
                
                // Áº©ÊîæÊéßÂà∂
                document.getElementById('zoomInBtn').addEventListener('click', () => this.zoom(1.2));
                document.getElementById('zoomOutBtn').addEventListener('click', () => this.zoom(0.8));
                
                // Â§ÑÁêÜÊåâÈíÆ
                document.getElementById('processBtn').addEventListener('click', () => this.processDocument());
                document.getElementById('resetBtn').addEventListener('click', () => this.resetSettings());
                document.getElementById('newFileBtn').addEventListener('click', () => this.selectNewFile());
                
                // ÊèêÂèñÊñáÊú¨Áõ∏ÂÖ≥
                document.getElementById('extractAllPagesBtn').addEventListener('click', () => this.setExtractAllPages());
                document.getElementById('copyTextBtn').addEventListener('click', () => this.copyExtractedText());
                
                // ÊãÜÂàÜÊñπÂºèÂàáÊç¢
                document.getElementById('splitMethod').addEventListener('change', (e) => this.updateSplitSettings(e.target.value));
                
                // ÂêàÂπ∂Êñá‰ª∂ÈÄâÊã©
                document.getElementById('mergeFilesInput').addEventListener('change', (e) => this.addMergeFiles(e.target.files));
                
                // ËæìÂá∫Ê†ºÂºèÂàáÊç¢
                document.getElementById('outputFormat').addEventListener('change', (e) => this.updateConvertSettings(e.target.value));
                
                // ÊªëÂùóÁªëÂÆö
                this.bindSliders();
                
                // ÁªìÊûúÊìç‰Ωú
                document.getElementById('downloadAllBtn').addEventListener('click', () => this.downloadAllFiles());
                document.getElementById('shareAllBtn').addEventListener('click', () => this.shareAllFiles());
                document.getElementById('processAnotherBtn').addEventListener('click', () => this.processAnother());
                
                // ÁõëÂê¨ËÆæÁΩÆÂèòÂåñ‰ª•ÂêØÁî®Â§ÑÁêÜÊåâÈíÆ
                this.bindSettingChanges();
            }
            
            bindSliders() {
                const imageQuality = document.getElementById('imageQuality');
                const imageQualityValue = document.getElementById('imageQualityValue');
                
                imageQuality.addEventListener('input', () => {
                    imageQualityValue.textContent = imageQuality.value + '%';
                });
            }
            
            bindSettingChanges() {
                const settings = ['extractStartPage', 'extractEndPage', 'splitInterval', 'pageRanges', 'outputFormat'];
                settings.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('input', () => this.enableProcessButton());
                        element.addEventListener('change', () => this.enableProcessButton());
                    }
                });
            }
            
            async loadDocument(file) {
                if (!this.isSupportedFormat(file)) {
                    const unsupportedFormatText = "alert unsupported document format" || '‰∏çÊîØÊåÅÁöÑÊñáÊ°£Ê†ºÂºèÔºÅËØ∑ÈÄâÊã© PDF, DOCX, TXT, RTF Êàñ HTML Êñá‰ª∂„ÄÇ';
                    alert(unsupportedFormatText);
                    return;
                }
                
                this.documentFile = file;
                this.updateDocumentInfo();
                
                try {
                    await this.parseDocument(file);
                    this.showWorkspace();
                    this.enableProcessButton();
                } catch (error) {
                    console.error('ÊñáÊ°£Ëß£ÊûêÂ§±Ë¥•:', error);
                    const parseFailedText = "alert document parse failed" || 'ÊñáÊ°£Ëß£ÊûêÂ§±Ë¥•: ';
                    alert(parseFailedText + error.message);
                }
            }
            
            isSupportedFormat(file) {
                const supportedTypes = [
                    'application/pdf',
                    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                    'application/msword',
                    'text/plain',
                    'text/rtf',
                    'text/html'
                ];
                
                return supportedTypes.includes(file.type) || 
                       file.name.toLowerCase().match(/\.(pdf|docx?|txt|rtf|html?)$/);
            }
            
            async parseDocument(file) {
                const fileType = file.type || this.getFileTypeFromName(file.name);
                
                if (fileType.includes('pdf')) {
                    await this.parsePDF(file);
                } else if (fileType.includes('text') || file.name.endsWith('.txt')) {
                    await this.parseTextFile(file);
                } else if (fileType.includes('html')) {
                    await this.parseHTMLFile(file);
                } else {
                    // For other formats, display basic information
                    const docTypeText = "text document type" || 'Document Type';
                    const fileSizeText = "text file size" || 'File Size';
                    this.documentContent = `${docTypeText}: ${fileType}\n${fileSizeText}: ${this.formatFileSize(file.size)}`;
                    this.totalPages = 1;
                    this.updatePreview();
                }
            }
            
            async parsePDF(file) {
                try {
                    const pdfLoadingText = "text pdf loading" || 'PDF document loaded, parsing...';
                    this.documentContent = pdfLoadingText;
                    this.updatePreview();
                    
                    // ‰ΩøÁî®PDF.jsËß£ÊûêPDF
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                    
                    this.totalPages = pdf.numPages;
                    this.pdfDocument = pdf; // ‰øùÂ≠òPDFÊñáÊ°£ÂØπË±°
                    
                    // Ê∏≤ÊüìÁ¨¨‰∏ÄÈ°µ‰Ωú‰∏∫È¢ÑËßà
                    await this.renderPDFPage(1);
                    
                    console.log('‚úÖ PDF parsing successful, pages:', this.totalPages);
                } catch (error) {
                    console.error('PDF parsing failed:', error);
                    this.documentContent = `PDF parsing failed: ${error.message}`;
                    this.totalPages = 0;
                    this.updatePreview();
                }
            }
            
            async renderPDFPage(pageNumber) {
                if (!this.pdfDocument) return;
                
                try {
                    const page = await this.pdfDocument.getPage(pageNumber);
                    
                    // Extract text content
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    
                    // Update current page content
                    this.documentContent = pageText || `PDF page ${pageNumber} - Unable to extract text content`;
                    this.currentPage = pageNumber;
                    this.updatePreview();
                    
                    // Optional: Render PDF page to canvas
                    const viewport = page.getViewport({ scale: 1.0 });
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    
                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;
                    
                    // Add canvas to preview area
                    const previewArea = document.getElementById('previewArea');
                    previewArea.innerHTML = '';
                    previewArea.appendChild(canvas);
                    canvas.style.maxWidth = '100%';
                    canvas.style.height = 'auto';
                    
                } catch (error) {
                    console.error('PDF page rendering failed:', error);
                    this.documentContent = `Page ${pageNumber} rendering failed: ${error.message}`;
                    this.updatePreview();
                }
            }
            
            async parseTextFile(file) {
                const text = await file.text();
                this.documentContent = text;
                this.totalPages = Math.ceil(text.length / 2000); // 2000 characters per page
                this.updatePreview();
            }
            
            async parseHTMLFile(file) {
                const html = await file.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                this.documentContent = doc.body.textContent || doc.body.innerText || html;
                this.totalPages = 1;
                this.updatePreview();
            }
            
            getFileTypeFromName(fileName) {
                const ext = fileName.toLowerCase().split('.').pop();
                const typeMap = {
                    'pdf': 'application/pdf',
                    'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                    'doc': 'application/msword',
                    'txt': 'text/plain',
                    'rtf': 'text/rtf',
                    'html': 'text/html',
                    'htm': 'text/html'
                };
                return typeMap[ext] || 'application/octet-stream';
            }
            
            updateDocumentInfo() {
                const fileName = this.documentFile.name;
                const fileSize = this.formatFileSize(this.documentFile.size);
                
                document.getElementById('documentFileName').textContent = fileName;
                document.getElementById('documentFileInfo').textContent = fileSize;
            }
            
            updatePreview() {
                const previewArea = document.getElementById('previewArea');
                const noPreviewText = "text no preview available" || 'Unable to preview this document content';
                const content = this.documentContent || noPreviewText;
                
                // Simple pagination display
                const wordsPerPage = 500;
                const words = content.split(' ');
                const startIndex = (this.currentPage - 1) * wordsPerPage;
                const endIndex = Math.min(startIndex + wordsPerPage, words.length);
                const pageContent = words.slice(startIndex, endIndex).join(' ');
                
                previewArea.innerHTML = `<pre style="white-space: pre-wrap; font-family: inherit;">${pageContent}</pre>`;
                
                // Update page information
                const pageInfoText = "text page format" || 'Page: {current} / {total}';
                document.getElementById('documentPageInfo').textContent = pageInfoText.replace('{current}', this.currentPage).replace('{total}', this.totalPages);
                document.getElementById('currentPageInput').value = this.currentPage;
                document.getElementById('currentPageInput').max = this.totalPages;
                
                // Update page control button states
                document.getElementById('firstPageBtn').disabled = this.currentPage <= 1;
                document.getElementById('prevPageBtn').disabled = this.currentPage <= 1;
                document.getElementById('nextPageBtn').disabled = this.currentPage >= this.totalPages;
                document.getElementById('lastPageBtn').disabled = this.currentPage >= this.totalPages;
                
                // Update default values for extraction settings
                document.getElementById('extractEndPage').value = this.totalPages;
                document.getElementById('extractEndPage').max = this.totalPages;
            }
            
            async goToPage(pageNum) {
                if (pageNum >= 1 && pageNum <= this.totalPages) {
                    this.currentPage = pageNum;
                    
                    if (this.pdfDocument) {
                        // If it's a PDF document, re-render the specified page
                        await this.renderPDFPage(pageNum);
                    } else {
                        // For other document types, use the original pagination logic
                        this.updatePreview();
                    }
                }
            }
            
            zoom(factor) {
                this.zoomLevel = Math.max(50, Math.min(200, this.zoomLevel * factor));
                document.getElementById('zoomLevel').textContent = Math.round(this.zoomLevel) + '%';
                
                const previewArea = document.getElementById('previewArea');
                previewArea.style.fontSize = (14 * this.zoomLevel / 100) + 'px';
            }
            
            showWorkspace() {
                document.getElementById('uploadArea').style.display = 'none';
                document.getElementById('processingWorkspace').style.display = 'block';
            }
            
            switchTab(tabName) {
                document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                
                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
                document.getElementById(`${tabName}Tab`).classList.add('active');
                
                this.currentTab = tabName;
                this.enableProcessButton();
            }
            
            enableProcessButton() {
                const processBtn = document.getElementById('processBtn');
                
                if (!this.documentFile) {
                    processBtn.disabled = true;
                    return;
                }
                
                switch (this.currentTab) {
                    case 'extract':
                        processBtn.disabled = false;
                        break;
                    case 'split':
                        processBtn.disabled = false;
                        break;
                    case 'merge':
                        processBtn.disabled = this.mergeFiles.length < 2;
                        break;
                    case 'convert':
                        const outputFormat = document.getElementById('outputFormat').value;
                        processBtn.disabled = !outputFormat;
                        break;
                    default:
                        processBtn.disabled = true;
                }
            }
            
            setExtractAllPages() {
                document.getElementById('extractStartPage').value = 1;
                document.getElementById('extractEndPage').value = this.totalPages;
            }
            
            updateSplitSettings(method) {
                const intervalSetting = document.getElementById('intervalSetting');
                const pageRangesSetting = document.getElementById('pageRangesSetting');
                
                intervalSetting.style.display = method === 'interval' ? 'block' : 'none';
                pageRangesSetting.style.display = method === 'pages' ? 'block' : 'none';
            }
            
            addMergeFiles(files) {
                Array.from(files).forEach(file => {
                    if (file.type === 'application/pdf') {
                        this.mergeFiles.push(file);
                    }
                });
                
                this.updateMergeFilesList();
                this.enableProcessButton();
            }
            
            updateMergeFilesList() {
                const list = document.getElementById('mergeFilesList');
                list.innerHTML = '';
                
                this.mergeFiles.forEach((file, index) => {
                    const item = document.createElement('div');
                    item.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 8px; background: var(--surface-color); border-radius: 4px; margin-bottom: 8px;';
                    item.innerHTML = `
                        <span>${file.name}</span>
                        <button onclick="documentProcessor.removeMergeFile(${index})" style="background: var(--error-color); color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer;">Remove</button>
                    `;
                    list.appendChild(item);
                });
            }
            
            removeMergeFile(index) {
                this.mergeFiles.splice(index, 1);
                this.updateMergeFilesList();
                this.enableProcessButton();
            }
            
            updateConvertSettings(format) {
                const imageQualitySetting = document.getElementById('imageQualitySetting');
                const imageDpiSetting = document.getElementById('imageDpiSetting');
                
                const showImageSettings = format === 'images';
                imageQualitySetting.style.display = showImageSettings ? 'block' : 'none';
                imageDpiSetting.style.display = showImageSettings ? 'block' : 'none';
            }
            
            async processDocument() {
                if (!this.documentFile) return;
                
                document.getElementById('progressSection').style.display = 'block';
                document.getElementById('processBtn').disabled = true;
                
                const startTime = Date.now();
                
                try {
                    this.processedFiles = [];
                    
                    switch (this.currentTab) {
                        case 'extract':
                            await this.extractText();
                            break;
                        case 'split':
                            await this.splitDocument();
                            break;
                        case 'merge':
                            await this.mergeDocuments();
                            break;
                        case 'convert':
                            await this.convertDocument();
                            break;
                    }
                    
                    if (this.processedFiles.length > 0 || this.currentTab === 'extract') {
                        this.showResults(startTime);
                    }
                } catch (error) {
                    console.error('Document processing failed:', error);
                    const processingFailedText = "alert processing failed" || 'Processing failed: ';
                    alert(processingFailedText + error.message);
                } finally {
                    document.getElementById('processBtn').disabled = false;
                }
            }
            
            async extractText() {
                const extractingText = "progress extracting text" || 'Extracting text...';
                this.updateProgress(30, extractingText);
                
                const startPage = parseInt(document.getElementById('extractStartPage').value) || 1;
                const endPage = parseInt(document.getElementById('extractEndPage').value) || this.totalPages;
                const preserveFormatting = document.getElementById('preserveFormatting').checked;
                const removeBlankLines = document.getElementById('removeBlankLines').checked;
                const extractImages = document.getElementById('extractImages').checked;
                
                let extractedText = '';
                let imageLinks = [];
                
                try {
                    if (this.pdfDocument) {
                        // Actual PDF text extraction
                        const totalPages = Math.min(endPage, this.totalPages);
                        
                        for (let pageNum = startPage; pageNum <= totalPages; pageNum++) {
                            this.updateProgress(30 + (pageNum - startPage) / (totalPages - startPage + 1) * 60, 
                                             "progress extracting page" ? "progress extracting page".replace('{pageNum}', pageNum) : `Extracting page ${pageNum}...`);
                            
                            try {
                                const page = await this.pdfDocument.getPage(pageNum);
                                
                                // Extract text content
                                const textContent = await page.getTextContent();
                                let pageText = '';
                                
                                if (preserveFormatting) {
                                    // Preserve formatting: consider text position information
                                    let lastY = null;
                                    textContent.items.forEach(item => {
                                        if (lastY !== null && Math.abs(item.transform[5] - lastY) > 5) {
                                            pageText += '\n';
                                        }
                                        pageText += item.str;
                                        if (item.str.endsWith(' ') === false && item.hasEOL === false) {
                                            pageText += ' ';
                                        }
                                        lastY = item.transform[5];
                                    });
                                } else {
                                    // Simple text extraction
                                    pageText = textContent.items.map(item => item.str).join(' ');
                                }
                                
                                if (pageText.trim()) {
                                    if (extractedText && !extractedText.endsWith('\n\n')) {
                                        extractedText += '\n\n';
                                    }
                                    extractedText += `=== Page ${pageNum} ===\n`;
                                    extractedText += pageText.trim() + '\n';
                                }
                                
                                // Extract image information (if this option is selected)
                                if (extractImages) {
                                    try {
                                        const operatorList = await page.getOperatorList();
                                        let imageCount = 0;
                                        for (let i = 0; i < operatorList.fnArray.length; i++) {
                                            if (operatorList.fnArray[i] === pdfjsLib.OPS.paintImageXObject) {
                                                imageCount++;
                                                imageLinks.push(`[Image ${pageNum}-${imageCount}] Located on page ${pageNum}`);
                                            }
                                        }
                                    } catch (imgError) {
                                        console.warn('Failed to extract image information:', imgError);
                                    }
                                }
                                
                            } catch (pageError) {
                                console.error(`Page ${pageNum} extraction failed:`, pageError);
                                extractedText += `\n=== Page ${pageNum} ===\n[Page extraction failed: ${pageError.message}]\n`;
                            }
                        }
                    } else {
                        // Non-PDF documents use original logic
                        extractedText = this.documentContent || "Unable to extract text content";
                    }
                    
                    // ÂêéÂ§ÑÁêÜ
                    if (removeBlankLines && extractedText) {
                        extractedText = extractedText.replace(/\n\s*\n\s*\n/g, '\n\n');
                    }
                    
                    // Ê∑ªÂä†ÂõæÁâáÈìæÊé•‰ø°ÊÅØ
                    if (imageLinks.length > 0) {
                        const foundImagesText = "text found images" || '=== ÂèëÁé∞ÁöÑÂõæÁâá ===';
                        extractedText += `\n\n${foundImagesText}\n`;
                        extractedText += imageLinks.join('\n');
                    }
                    
                    if (!extractedText.trim()) {
                        const noTextExtractedText = "text no text extracted" || 'Êú™ËÉΩÊèêÂèñÂà∞ÊñáÊú¨ÂÜÖÂÆπ„ÄÇËøôÂèØËÉΩÊòØ‰∏Ä‰∏™ÂõæÁâáÂûãPDFÊàñÊâ´ÊèèÊñáÊ°£„ÄÇ';
                        extractedText = noTextExtractedText;
                    }
                    
                    const extractionCompleteText = "progress extraction complete" || 'ÊñáÊú¨ÊèêÂèñÂÆåÊàêÔºÅ';
                    this.updateProgress(100, extractionCompleteText);
                    
                } catch (error) {
                    console.error('ÊñáÊú¨ÊèêÂèñÂ§±Ë¥•:', error);
                    const extractionFailedText = "text extraction failed" || 'ÊñáÊú¨ÊèêÂèñÂ§±Ë¥•';
                    extractedText = `${extractionFailedText}: ${error.message}`;
                    const extractionFailedProgressText = "progress extraction failed" || 'ÊèêÂèñÂ§±Ë¥•ÔºÅ';
                    this.updateProgress(100, extractionFailedProgressText);
                }
                
                // ÊòæÁ§∫ÊèêÂèñÁªìÊûú
                document.getElementById('extractedText').textContent = extractedText;
                document.getElementById('extractedTextArea').style.display = 'block';
            }
            
            async splitDocument() {
                const splittingText = "progress splitting document" || 'Ê≠£Âú®ÊãÜÂàÜÊñáÊ°£...';
                this.updateProgress(30, splittingText);
                
                const method = document.getElementById('splitMethod').value;
                let fileCount = 1;
                
                if (method === 'interval') {
                    const interval = parseInt(document.getElementById('splitInterval').value) || 10;
                    fileCount = Math.ceil(this.totalPages / interval);
                } else if (method === 'pages') {
                    const ranges = document.getElementById('pageRanges').value;
                    fileCount = ranges.split(',').length;
                }
                
                // Ê®°ÊãüÊñáÊ°£ÊãÜÂàÜ
                for (let i = 0; i < fileCount; i++) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    const creatingDocText = "progress creating document" ? "progress creating document".replace('{num}', i + 1) : `Ê≠£Âú®ÂàõÂª∫Á¨¨ ${i + 1} ‰∏™ÊñáÊ°£...`;
                    this.updateProgress(30 + (i + 1) / fileCount * 60, creatingDocText);
                    
                    // ÂàõÂª∫Ê®°ÊãüÊñá‰ª∂
                    const fileName = this.documentFile.name.replace(/\.[^.]+$/, `_part${i + 1}.pdf`);
                    const simulatedPdfContent = "text simulated pdf content" || 'Ê®°ÊãüPDFÂÜÖÂÆπ';
                    const blob = new Blob([simulatedPdfContent], { type: 'application/pdf' });
                    this.processedFiles.push(new File([blob], fileName, { type: 'application/pdf' }));
                }
                
                const splittingCompleteText = "progress splitting complete" || 'ÊñáÊ°£ÊãÜÂàÜÂÆåÊàêÔºÅ';
                this.updateProgress(100, splittingCompleteText);
            }
            
            async mergeDocuments() {
                const mergingText = "progress merging documents" || 'Ê≠£Âú®ÂêàÂπ∂ÊñáÊ°£...';
                this.updateProgress(30, mergingText);
                
                // Ê®°ÊãüÊñáÊ°£ÂêàÂπ∂
                for (let i = 0; i < this.mergeFiles.length; i++) {
                    await new Promise(resolve => setTimeout(resolve, 300));
                    const processingDocText = "progress processing document" ? "progress processing document".replace('{num}', i + 1) : `Ê≠£Âú®Â§ÑÁêÜÁ¨¨ ${i + 1} ‰∏™ÊñáÊ°£...`;
                    this.updateProgress(30 + (i + 1) / this.mergeFiles.length * 60, processingDocText);
                }
                
                // ÂàõÂª∫ÂêàÂπ∂ÂêéÁöÑÊñá‰ª∂
                const mergedFileName = 'merged_document.pdf';
                const mergedPdfContent = "text merged pdf content" || 'ÂêàÂπ∂ÂêéÁöÑPDFÂÜÖÂÆπ';
                const blob = new Blob([mergedPdfContent], { type: 'application/pdf' });
                this.processedFiles.push(new File([blob], mergedFileName, { type: 'application/pdf' }));
                
                const mergingCompleteText = "progress merging complete" || 'ÊñáÊ°£ÂêàÂπ∂ÂÆåÊàêÔºÅ';
                this.updateProgress(100, mergingCompleteText);
            }
            
            async convertDocument() {
                const outputFormat = document.getElementById('outputFormat').value;
                const convertingToText = "progress converting to" ? "progress converting to".replace('{format}', outputFormat.toUpperCase()) : `Ê≠£Âú®ËΩ¨Êç¢‰∏∫ ${outputFormat.toUpperCase()}...`;
                this.updateProgress(30, convertingToText);
                
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                let fileName = this.documentFile.name.replace(/\.[^.]+$/, '');
                let mimeType = 'application/octet-stream';
                let content = "text converted document content" || 'ËΩ¨Êç¢ÂêéÁöÑÊñáÊ°£ÂÜÖÂÆπ';
                
                switch (outputFormat) {
                    case 'pdf':
                        fileName += '.pdf';
                        mimeType = 'application/pdf';
                        break;
                    case 'docx':
                        fileName += '.docx';
                        mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
                        break;
                    case 'txt':
                        fileName += '.txt';
                        mimeType = 'text/plain';
                        const convertedTextContent = "text converted text content" || 'ËΩ¨Êç¢ÂêéÁöÑÊñáÊú¨ÂÜÖÂÆπ';
                        content = this.documentContent || convertedTextContent;
                        break;
                    case 'html':
                        fileName += '.html';
                        mimeType = 'text/html';
                        const convertedHtmlContent = "text converted html content" || 'ËΩ¨Êç¢ÂêéÁöÑHTMLÂÜÖÂÆπ';
    <!-- Share Integration -->
    <script src="device-selector.js"></script>
    <script src="add-share-integration.js"></script>
                        content = `<html><body><p>${this.documentContent || convertedHtmlContent}</p></body></html>`;
                        break;
                    case 'images':
                        // ÂØπ‰∫éÂõæÁâáÔºåÂàõÂª∫Â§ö‰∏™Êñá‰ª∂
                        for (let i = 1; i <= this.totalPages; i++) {
                            const imageFileName = `${fileName}_page${i}.jpg`;
                            const simulatedImageContent = "text simulated image content" || 'Ê®°ÊãüÂõæÁâáÂÜÖÂÆπ';
                            const blob = new Blob([simulatedImageContent], { type: 'image/jpeg' });
                            this.processedFiles.push(new File([blob], imageFileName, { type: 'image/jpeg' }));
                        }
                        const conversionCompleteText = "progress conversion complete" || 'Ê†ºÂºèËΩ¨Êç¢ÂÆåÊàêÔºÅ';
                        this.updateProgress(100, conversionCompleteText);
                        return;
                }
                
                const blob = new Blob([content], { type: mimeType });
                this.processedFiles.push(new File([blob], fileName, { type: mimeType }));
                
                const conversionCompleteText2 = "progress conversion complete" || 'Ê†ºÂºèËΩ¨Êç¢ÂÆåÊàêÔºÅ';
                this.updateProgress(100, conversionCompleteText2);
            }
            
            showResults(startTime) {
                const processingTime = ((Date.now() - startTime) / 1000).toFixed(1);
                const originalSize = this.documentFile.size;
                let totalResultSize = 0;
                
                this.processedFiles.forEach(file => {
                    totalResultSize += file.size;
                });
                
                document.getElementById('originalFileSize').textContent = this.formatFileSize(originalSize);
                document.getElementById('resultFileSize').textContent = this.formatFileSize(totalResultSize);
                document.getElementById('pageCount').textContent = this.totalPages;
                document.getElementById('processingTime').textContent = processingTime + 's';
                
                // ÊòæÁ§∫ÁªìÊûúÊñá‰ª∂ÂàóË°®
                this.updateResultFilesList();
                
                document.getElementById('resultSection').style.display = 'block';
                document.getElementById('resultSection').scrollIntoView({ behavior: 'smooth' });
            }
            
            updateResultFilesList() {
                const list = document.getElementById('resultFilesList');
                list.innerHTML = '';
                
                this.processedFiles.forEach((file, index) => {
                    const item = document.createElement('div');
                    item.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 12px; background: var(--bg-color-secondary); border-radius: 6px; margin-bottom: 10px;';
                    item.innerHTML = `
                        <div>
                            <strong>${file.name}</strong><br>
                            <small style="color: var(--text-secondary);">${this.formatFileSize(file.size)} ‚Ä¢ ${file.type}</small>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button onclick="documentProcessor.downloadFile(${index})" class="page-btn">‰∏ãËΩΩ</button>
                            <button onclick="documentProcessor.shareFile(${index})" class="page-btn">ÂàÜ‰∫´</button>
                        </div>
                    `;
                    list.appendChild(item);
                });
            }
            
            downloadFile(index) {
                const file = this.processedFiles[index];
                const url = URL.createObjectURL(file);
                const a = document.createElement('a');
                a.href = url;
                a.download = file.name;
                a.click();
                URL.revokeObjectURL(url);
            }
            
            shareFile(index) {
                const file = this.processedFiles[index];
                
                if (window.ui && window.ui.filesQueue) {
                    window.ui.filesQueue.push(file);
                    const fileAddedToShareText = "alert file added to share" || 'Â∑≤Ê∑ªÂä†Âà∞ÂàÜ‰∫´ÂàóË°®ÔºÅ';
                    alert(`${file.name} ${fileAddedToShareText}`);
                } else {
                    const shareUnavailableText = "alert share unavailable" || 'ÂàÜ‰∫´ÂäüËÉΩÊöÇ‰∏çÂèØÁî®ÔºåËØ∑ÂÖàËøîÂõûÂàÜ‰∫´È°µÈù¢';
                    alert(shareUnavailableText);
                }
            }
            
            downloadAllFiles() {
                this.processedFiles.forEach((file, index) => {
                    setTimeout(() => this.downloadFile(index), index * 500);
                });
            }
            
            shareAllFiles() {
                if (window.ui && window.ui.filesQueue) {
                    this.processedFiles.forEach(file => {
                        window.ui.filesQueue.push(file);
                    });
                    const filesAddedToShareText = "alert files added to share" || '‰∏™Êñá‰ª∂Â∑≤Ê∑ªÂä†Âà∞ÂàÜ‰∫´ÂàóË°®ÔºÅ';
                    alert(`${this.processedFiles.length} ${filesAddedToShareText}`);
                } else {
                    const shareUnavailableText2 = "alert share unavailable" || 'ÂàÜ‰∫´ÂäüËÉΩÊöÇ‰∏çÂèØÁî®ÔºåËØ∑ÂÖàËøîÂõûÂàÜ‰∫´È°µÈù¢';
                    alert(shareUnavailableText2);
                }
            }
            
            copyExtractedText() {
                const text = document.getElementById('extractedText').textContent;
                navigator.clipboard.writeText(text).then(() => {
                    const textCopiedText = "alert text copied" || 'ÊñáÊú¨Â∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥ÊùøÔºÅ';
                    alert(textCopiedText);
                }).catch(err => {
                    console.error('Â§çÂà∂Â§±Ë¥•:', err);
                    const copyFailedText = "alert copy failed" || 'Â§çÂà∂Â§±Ë¥•ÔºåËØ∑ÊâãÂä®ÈÄâÊã©ÊñáÊú¨Â§çÂà∂';
                    alert(copyFailedText);
                });
            }
            
            updateProgress(percent, text) {
                document.getElementById('progressFill').style.width = percent + '%';
                document.getElementById('progressText').textContent = text;
            }
            
            formatFileSize(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            resetSettings() {
                // ÈáçÁΩÆÊâÄÊúâËÆæÁΩÆÂà∞ÈªòËÆ§ÂÄº
                document.getElementById('extractStartPage').value = 1;
                document.getElementById('extractEndPage').value = this.totalPages;
                document.getElementById('splitMethod').value = 'pages';
                document.getElementById('splitInterval').value = 10;
                document.getElementById('outputFormat').value = 'pdf';
                // ... ÈáçÁΩÆÂÖ∂‰ªñËÆæÁΩÆ
                
                this.updateSplitSettings('pages');
                this.updateConvertSettings('pdf');
            }
            
            selectNewFile() {
                document.getElementById('fileInput').click();
            }
            
            processAnother() {
                document.getElementById('resultSection').style.display = 'none';
                document.getElementById('progressSection').style.display = 'none';
                document.getElementById('extractedTextArea').style.display = 'none';
                this.processedFiles = [];
                this.resetSettings();
            }
        }
        
        // ÂàùÂßãÂåñ
        let documentProcessor;
        document.addEventListener('DOMContentLoaded', () => {
            documentProcessor = new DocumentProcessor();
            // Initialize i18n after document processor
            if (typeof initializeI18n === 'function') {
                initializeI18n();
            }
        });
    </script>

    <script>
        // Initialize document processor on page load
        let documentProcessor;
        document.addEventListener('DOMContentLoaded', () => {
            documentProcessor = new DocumentProcessor();
        });
    </script>
    <!-- Share Integration -->
    <script src="device-selector.js"></script>
    <script src="add-share-integration.js"></script>
</body>
</html>