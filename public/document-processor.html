<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="document_processor_title">æ–‡æ¡£å¤„ç†å™¨ - DropShare</title>
    <link rel="stylesheet" type="text/css" href="styles.css">
    <style>
        body {
            padding: 20px;
            background: var(--bg-color);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .page-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--border-color);
        }
        
        .header-buttons {
            display: flex;
            gap: 12px;
        }
        
        .back-button {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            color: var(--primary-color);
            text-decoration: none;
            border: 1px solid var(--primary-color);
            border-radius: 8px;
            transition: all 0.3s ease;
            font-size: 14px;
        }
        
        .back-button:hover {
            background: var(--primary-color);
            color: white;
        }
        
        .processor-container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 30px;
            box-shadow: var(--shadow-sm);
        }
        
        .upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            margin-bottom: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .upload-area:hover, .upload-area.dragover {
            border-color: var(--primary-color);
            background: var(--bg-color-secondary);
        }
        
        .processing-workspace {
            display: none;
        }
        
        .tabs {
            display: flex;
            gap: 0;
            margin-bottom: 20px;
            background: var(--border-color);
            border-radius: 8px;
            overflow: hidden;
        }
        
        .tab {
            flex: 1;
            padding: 12px 20px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
            color: var(--text-secondary);
        }
        
        .tab.active {
            background: var(--primary-color);
            color: white;
        }
        
        .tab-content {
            display: none;
            padding: 20px;
            background: var(--bg-color-secondary);
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .document-preview {
            width: 100%;
            margin: 20px 0;
            background: var(--surface-color);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            max-height: 500px;
        }
        
        .preview-header {
            padding: 15px 20px;
            background: var(--primary-color);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .document-info h4 {
            margin: 0 0 4px 0;
            font-size: 16px;
        }
        
        .document-info p {
            margin: 0;
            font-size: 12px;
            opacity: 0.8;
        }
        
        .preview-controls {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .preview-area {
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .page-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .page-btn {
            padding: 6px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--surface-color);
            cursor: pointer;
            font-size: 12px;
        }
        
        .page-btn:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        
        .page-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .page-input {
            width: 60px;
            padding: 4px 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            text-align: center;
            font-size: 12px;
        }
        
        .tool-group {
            background: var(--surface-color);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            margin-bottom: 15px;
        }
        
        .tool-group h4 {
            margin-bottom: 15px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .settings-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        
        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .setting-item label {
            font-weight: 500;
            color: var(--text-primary);
            font-size: 14px;
        }
        
        .setting-item input, .setting-item select {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-color-secondary);
            color: var(--text-color);
            font-size: 14px;
        }
        
        .range-input {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .range-input input[type="range"] {
            flex: 1;
        }
        
        .range-value {
            min-width: 40px;
            text-align: center;
            font-weight: 500;
            color: var(--primary-color);
        }
        
        .page-range {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }
        
        .page-range input {
            width: 60px;
        }
        
        .process-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 30px 0;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
            font-size: 14px;
        }
        
        .btn-primary {
            background: var(--primary-color);
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            background: var(--primary-hover);
        }
        
        .btn-secondary {
            background: var(--border-color);
            color: var(--text-color);
        }
        
        .btn-secondary:hover {
            background: var(--text-secondary);
            color: white;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 15px 0;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .text-extraction-result {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 13px;
            line-height: 1.5;
        }
        
        .progress-section {
            display: none;
            margin: 20px 0;
            padding: 20px;
            background: var(--bg-color-secondary);
            border-radius: 8px;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--surface-color);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: var(--primary-color);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .result-section {
            display: none;
            margin-top: 30px;
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--surface-color);
        }
        
        .result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-item {
            text-align: center;
            padding: 15px;
            background: var(--bg-color-secondary);
            border-radius: 8px;
        }
        
        .stat-label {
            display: block;
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 4px;
            text-transform: uppercase;
            font-weight: 500;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        @media (max-width: 768px) {
            .processor-container {
                padding: 20px;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .settings-panel {
                grid-template-columns: 1fr;
            }
            
            .process-actions {
                flex-direction: column;
            }
            
            .process-actions .btn {
                width: 100%;
            }
            
            .result-stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="page-header">
        <h1 data-i18n="document_processor_heading">ğŸ“„ æ–‡æ¡£å¤„ç†å™¨</h1>
        <div class="header-buttons">
            <div class="control-buttons">
                <div class="lang-selector">
                    <select id="language-selector" title="é€‰æ‹©è¯­è¨€" data-i18n="title_select_language">
                        <option value="en">English</option>
                        <option value="zh">ä¸­æ–‡ç®€ä½“</option>
                        <option value="zh-tw">ä¸­æ–‡ç¹é«”</option>
                        <option value="ja">æ—¥æœ¬èª</option>
                        <option value="fr">FranÃ§ais</option>
                        <option value="es">EspaÃ±ol</option>
                        <option value="de">Deutsch</option>
                        <option value="pt">PortuguÃªs</option>
                        <option value="ru">Ğ ÑƒÑÑĞºĞ¸Ğ¹</option>
                        <option value="ar">Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</option>
                        <option value="ko">í•œêµ­ì–´</option>
                    </select>
                </div>
            </div>
            <a href="document-tools.html" class="back-button" data-i18n="back_to_document_tools">â† æ–‡æ¡£å·¥å…·</a>
            <a href="index.html" class="back-button" data-i18n="btn_home">ğŸ  é¦–é¡µ</a>
        </div>
    </div>
    
    <div class="processor-container">
        <div class="upload-area" id="uploadArea">
            <div style="font-size: 3em; margin-bottom: 15px;">ğŸ“„</div>
            <h3 data-i18n="drop_documents_here">æ‹–æ‹½æ–‡æ¡£æ–‡ä»¶åˆ°è¿™é‡Œæˆ–ç‚¹å‡»é€‰æ‹©</h3>
            <p style="color: var(--text-secondary); margin-bottom: 20px;" data-i18n="supported_formats_document">æ”¯æŒ PDF, DOCX, TXT, RTF, HTML ç­‰æ ¼å¼</p>
            <input type="file" id="fileInput" accept=".pdf,.docx,.txt,.rtf,.html,.doc" style="display: none;">
            <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()" data-i18n="btn_select_document">é€‰æ‹©æ–‡æ¡£æ–‡ä»¶</button>
        </div>
        
        <div class="processing-workspace" id="processingWorkspace">
            <div class="document-preview">
                <div class="preview-header">
                    <div class="document-info">
                        <h4 id="documentFileName" data-i18n="text_no_file_selected">æœªé€‰æ‹©æ–‡ä»¶</h4>
                        <p id="documentFileInfo">-</p>
                    </div>
                    <div class="document-actions">
                        <span id="documentPageInfo" data-i18n="text_page_info">é¡µé¢: - / -</span>
                    </div>
                </div>
                <div class="preview-controls">
                    <div class="page-controls">
                        <button class="page-btn" id="firstPageBtn">â®ï¸</button>
                        <button class="page-btn" id="prevPageBtn">â—€ï¸</button>
                        <input type="number" id="currentPageInput" class="page-input" min="1" value="1">
                        <button class="page-btn" id="nextPageBtn">â–¶ï¸</button>
                        <button class="page-btn" id="lastPageBtn">â­ï¸</button>
                    </div>
                    <div class="zoom-controls">
                        <button class="page-btn" id="zoomOutBtn">ğŸ”-</button>
                        <span id="zoomLevel">100%</span>
                        <button class="page-btn" id="zoomInBtn">ğŸ”+</button>
                    </div>
                </div>
                <div class="preview-area" id="previewArea">
                    <p style="text-align: center; color: var(--text-secondary); margin: 40px 0;" data-i18n="select_file_to_preview">è¯·é€‰æ‹©æ–‡æ¡£æ–‡ä»¶æ¥é¢„è§ˆ</p>
                </div>
            </div>
            
            <div class="tabs">
                <button class="tab active" data-tab="extract" data-i18n="tab_extract">æ–‡æœ¬æå–</button>
                <button class="tab" data-tab="split" data-i18n="tab_split">æ–‡æ¡£æ‹†åˆ†</button>
                <button class="tab" data-tab="merge" data-i18n="tab_merge">æ–‡æ¡£åˆå¹¶</button>
                <button class="tab" data-tab="convert" data-i18n="tab_convert">æ ¼å¼è½¬æ¢</button>
            </div>
            
            <!-- æ–‡æœ¬æå– -->
            <div class="tab-content active" id="extractTab">
                <div class="tool-group">
                    <h4>ğŸ“ æ–‡æœ¬æå–è®¾ç½®</h4>
                    <div class="page-range">
                        <label data-i18n="label_extract_pages">æå–é¡µé¢:</label>
                        <input type="number" id="extractStartPage" data-i18n="placeholder_start_page" placeholder="èµ·å§‹é¡µ" min="1" value="1">
                        <span data-i18n="text_to">åˆ°</span>
                        <input type="number" id="extractEndPage" data-i18n="placeholder_end_page" placeholder="ç»“æŸé¡µ" min="1">
                        <button class="page-btn" id="extractAllPagesBtn" data-i18n="btn_all_pages">å…¨éƒ¨é¡µé¢</button>
                    </div>
                    
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="preserveFormatting" checked>
                            <label for="preserveFormatting" data-i18n="label_preserve_formatting">ä¿æŒæ ¼å¼</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="extractImages">
                            <label for="extractImages" data-i18n="label_extract_image_links">æå–å›¾ç‰‡é“¾æ¥</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="removeBlankLines">
                            <label for="removeBlankLines" data-i18n="label_remove_blank_lines">ç§»é™¤ç©ºè¡Œ</label>
                        </div>
                    </div>
                </div>
                
                <div id="extractedTextArea" class="text-extraction-result" style="display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <strong data-i18n="label_extracted_text">æå–çš„æ–‡æœ¬:</strong>
                        <button class="page-btn" id="copyTextBtn" data-i18n="btn_copy_text">å¤åˆ¶æ–‡æœ¬</button>
                    </div>
                    <div id="extractedText"></div>
                </div>
            </div>
            
            <!-- æ–‡æ¡£æ‹†åˆ† -->
            <div class="tab-content" id="splitTab">
                <div class="tool-group">
                    <h4 data-i18n="split_settings">âœ‚ï¸ æ–‡æ¡£æ‹†åˆ†è®¾ç½®</h4>
                    <div class="settings-panel">
                        <div class="setting-item">
                            <label data-i18n="split_method_label">æ‹†åˆ†æ–¹å¼:</label>
                            <select id="splitMethod">
                                <option value="pages" data-i18n="split_by_range">æŒ‰é¡µé¢èŒƒå›´</option>
                                <option value="interval" data-i18n="split_by_pages">æŒ‰é—´éš”é¡µæ•°</option>
                                <option value="bookmarks" data-i18n="split_by_bookmarks">æŒ‰ä¹¦ç­¾</option>
                            </select>
                        </div>
                        
                        <div class="setting-item" id="intervalSetting">
                            <label data-i18n="pages_per_file">æ¯ä¸ªæ–‡ä»¶é¡µæ•°:</label>
                            <input type="number" id="splitInterval" value="10" min="1">
                        </div>
                    </div>
                    
                    <div id="pageRangesSetting" style="display: none;">
                        <label data-i18n="page_range">é¡µé¢èŒƒå›´ (ç”¨é€—å·åˆ†éš”, å¦‚: 1-5, 10-15, 20):</label>
                        <input type="text" id="pageRanges" data-i18n="placeholder_page_ranges" placeholder="1-5, 10-15, 20" style="width: 100%; margin-top: 8px;">
                    </div>
                </div>
            </div>
            
            <!-- æ–‡æ¡£åˆå¹¶ -->
            <div class="tab-content" id="mergeTab">
                <div class="tool-group">
                    <h4>ğŸ”— æ–‡æ¡£åˆå¹¶è®¾ç½®</h4>
                    <p style="margin-bottom: 15px; color: var(--text-secondary);">
                        <span data-i18n="text_merge_multiple_pdfs">å°†å¤šä¸ªPDFæ–‡æ¡£åˆå¹¶ä¸ºä¸€ä¸ªæ–‡æ¡£ã€‚è¯·ä¸Šä¼ å¤šä¸ªæ–‡ä»¶ã€‚</span>
                    </p>
                    
                    <div style="margin: 15px 0;">
                        <input type="file" id="mergeFilesInput" accept=".pdf" multiple style="display: none;">
                        <button class="btn btn-secondary" onclick="document.getElementById('mergeFilesInput').click()">
                            <span data-i18n="btn_select_documents_to_merge">é€‰æ‹©è¦åˆå¹¶çš„æ–‡æ¡£</span>
                        </button>
                    </div>
                    
                    <div id="mergeFilesList" style="margin: 15px 0;"></div>
                    
                    <div class="checkbox-item">
                        <input type="checkbox" id="addBookmarks" checked>
                        <label for="addBookmarks" data-i18n="label_add_bookmarks_for_each_document">ä¸ºæ¯ä¸ªæ–‡æ¡£æ·»åŠ ä¹¦ç­¾</label>
                    </div>
                </div>
            </div>
            
            <!-- æ ¼å¼è½¬æ¢ -->
            <div class="tab-content" id="convertTab">
                <div class="tool-group">
                    <h4>ğŸ”„ æ ¼å¼è½¬æ¢è®¾ç½®</h4>
                    <div class="settings-panel">
                        <div class="setting-item">
                            <label data-i18n="label_output_format">è¾“å‡ºæ ¼å¼:</label>
                            <select id="outputFormat">
                                <option value="pdf">PDF</option>
                                <option value="docx" data-i18n="option_word_document">Word æ–‡æ¡£ (.docx)</option>
                                <option value="txt" data-i18n="option_plain_text">çº¯æ–‡æœ¬ (.txt)</option>
                                <option value="html" data-i18n="option_html_webpage">HTML ç½‘é¡µ</option>
                                <option value="rtf" data-i18n="option_rtf_document">RTF æ–‡æ¡£</option>
                                <option value="images" data-i18n="option_images">å›¾ç‰‡ (JPG/PNG)</option>
                            </select>
                        </div>
                        
                        <div class="setting-item" id="imageQualitySetting" style="display: none;">
                            <label data-i18n="label_image_quality">å›¾ç‰‡è´¨é‡:</label>
                            <div class="range-input">
                                <input type="range" id="imageQuality" min="50" max="100" value="90">
                                <span class="range-value" id="imageQualityValue">90%</span>
                            </div>
                        </div>
                        
                        <div class="setting-item" id="imageDpiSetting" style="display: none;">
                            <label data-i18n="label_image_dpi">å›¾ç‰‡DPI:</label>
                            <select id="imageDpi">
                                <option value="72" data-i18n="option_72_dpi_web">72 DPI (ç½‘é¡µ)</option>
                                <option value="150" selected data-i18n="option_150_dpi_standard">150 DPI (æ ‡å‡†)</option>
                                <option value="300" data-i18n="option_300_dpi_high_quality">300 DPI (é«˜è´¨é‡)</option>
                                <option value="600" data-i18n="option_600_dpi_print">600 DPI (æ‰“å°)</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="process-actions">
                <button class="btn btn-primary" id="processBtn" disabled data-i18n="btn_start_processing">å¼€å§‹å¤„ç†</button>
                <button class="btn btn-secondary" id="resetBtn" data-i18n="btn_reset_settings">é‡ç½®è®¾ç½®</button>
                <button class="btn btn-secondary" id="newFileBtn" data-i18n="btn_select_new_document">é€‰æ‹©æ–°æ–‡æ¡£</button>
            </div>
            
            <div class="progress-section" id="progressSection">
                <h4 data-i18n="heading_processing_progress">å¤„ç†è¿›åº¦:</h4>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div id="progressText" data-i18n="text_ready_to_process">å‡†å¤‡å¤„ç†...</div>
            </div>
            
            <div class="result-section" id="resultSection">
                <h3 data-i18n="heading_processing_results">å¤„ç†ç»“æœ</h3>
                
                <div class="result-stats">
                    <div class="stat-item">
                        <span class="stat-label" data-i18n="label_original_size">åŸå§‹å¤§å°</span>
                        <span class="stat-value" id="originalFileSize">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label" data-i18n="label_processed_size">å¤„ç†åå¤§å°</span>
                        <span class="stat-value" id="resultFileSize">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label" data-i18n="label_page_count">é¡µé¢æ•°é‡</span>
                        <span class="stat-value" id="pageCount">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label" data-i18n="label_processing_time">å¤„ç†æ—¶é—´</span>
                        <span class="stat-value" id="processingTime">-</span>
                    </div>
                </div>
                
                <div id="resultFilesList"></div>
                
                <div class="process-actions">
                    <button class="btn btn-primary" id="downloadAllBtn" data-i18n="btn_download_all_files">ä¸‹è½½æ‰€æœ‰æ–‡ä»¶</button>
                    <button class="btn btn-primary" id="shareAllBtn" data-i18n="btn_share_all_files">åˆ†äº«æ‰€æœ‰æ–‡ä»¶</button>
                    <button class="btn btn-secondary" id="processAnotherBtn" data-i18n="btn_process_another_document">å¤„ç†å…¶ä»–æ–‡æ¡£</button>
                </div>
            </div>
        </div>
    </div>

    <!-- PDF.js Library -->
    <script src="https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
    <script>
        // PDF.js worker setup
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js';
        }
    </script>

    <script>
        // å›½é™…åŒ–è¾…åŠ©å‡½æ•°
        function getI18nText(key) {
            if (window.DROPSHARE_I18N && typeof window.DROPSHARE_I18N.translate === 'function') {
                return window.DROPSHARE_I18N.translate(key);
            }
            return null;
        }

        class DocumentProcessor {
            constructor() {
                this.documentFile = null;
                this.currentPage = 1;
                this.totalPages = 0;
                this.zoomLevel = 100;
                this.currentTab = 'extract';
                this.processedFiles = [];
                this.mergeFiles = [];
                this.documentContent = null;
                
                this.init();
            }
            
            init() {
                this.bindEvents();
            }
            
            bindEvents() {
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                
                // æ‹–æ‹½ä¸Šä¼ 
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.loadDocument(files[0]);
                    }
                });
                
                // æ–‡ä»¶é€‰æ‹©
                fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.loadDocument(e.target.files[0]);
                    }
                });
                
                // æ ‡ç­¾åˆ‡æ¢
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', () => this.switchTab(tab.dataset.tab));
                });
                
                // é¡µé¢å¯¼èˆª
                document.getElementById('firstPageBtn').addEventListener('click', () => this.goToPage(1));
                document.getElementById('prevPageBtn').addEventListener('click', () => this.goToPage(this.currentPage - 1));
                document.getElementById('nextPageBtn').addEventListener('click', () => this.goToPage(this.currentPage + 1));
                document.getElementById('lastPageBtn').addEventListener('click', () => this.goToPage(this.totalPages));
                document.getElementById('currentPageInput').addEventListener('change', (e) => this.goToPage(parseInt(e.target.value)));
                
                // ç¼©æ”¾æ§åˆ¶
                document.getElementById('zoomInBtn').addEventListener('click', () => this.zoom(1.2));
                document.getElementById('zoomOutBtn').addEventListener('click', () => this.zoom(0.8));
                
                // å¤„ç†æŒ‰é’®
                document.getElementById('processBtn').addEventListener('click', () => this.processDocument());
                document.getElementById('resetBtn').addEventListener('click', () => this.resetSettings());
                document.getElementById('newFileBtn').addEventListener('click', () => this.selectNewFile());
                
                // æå–æ–‡æœ¬ç›¸å…³
                document.getElementById('extractAllPagesBtn').addEventListener('click', () => this.setExtractAllPages());
                document.getElementById('copyTextBtn').addEventListener('click', () => this.copyExtractedText());
                
                // æ‹†åˆ†æ–¹å¼åˆ‡æ¢
                document.getElementById('splitMethod').addEventListener('change', (e) => this.updateSplitSettings(e.target.value));
                
                // åˆå¹¶æ–‡ä»¶é€‰æ‹©
                document.getElementById('mergeFilesInput').addEventListener('change', (e) => this.addMergeFiles(e.target.files));
                
                // è¾“å‡ºæ ¼å¼åˆ‡æ¢
                document.getElementById('outputFormat').addEventListener('change', (e) => this.updateConvertSettings(e.target.value));
                
                // æ»‘å—ç»‘å®š
                this.bindSliders();
                
                // ç»“æœæ“ä½œ
                document.getElementById('downloadAllBtn').addEventListener('click', () => this.downloadAllFiles());
                document.getElementById('shareAllBtn').addEventListener('click', () => this.shareAllFiles());
                document.getElementById('processAnotherBtn').addEventListener('click', () => this.processAnother());
                
                // ç›‘å¬è®¾ç½®å˜åŒ–ä»¥å¯ç”¨å¤„ç†æŒ‰é’®
                this.bindSettingChanges();
            }
            
            bindSliders() {
                const imageQuality = document.getElementById('imageQuality');
                const imageQualityValue = document.getElementById('imageQualityValue');
                
                imageQuality.addEventListener('input', () => {
                    imageQualityValue.textContent = imageQuality.value + '%';
                });
            }
            
            bindSettingChanges() {
                const settings = ['extractStartPage', 'extractEndPage', 'splitInterval', 'pageRanges', 'outputFormat'];
                settings.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('input', () => this.enableProcessButton());
                        element.addEventListener('change', () => this.enableProcessButton());
                    }
                });
            }
            
            async loadDocument(file) {
                if (!this.isSupportedFormat(file)) {
                    const unsupportedFormatText = getI18nText('alert_unsupported_document_format') || 'ä¸æ”¯æŒçš„æ–‡æ¡£æ ¼å¼ï¼è¯·é€‰æ‹© PDF, DOCX, TXT, RTF æˆ– HTML æ–‡ä»¶ã€‚';
                    alert(unsupportedFormatText);
                    return;
                }
                
                this.documentFile = file;
                this.updateDocumentInfo();
                
                try {
                    await this.parseDocument(file);
                    this.showWorkspace();
                    this.enableProcessButton();
                } catch (error) {
                    console.error('æ–‡æ¡£è§£æå¤±è´¥:', error);
                    const parseFailedText = getI18nText('alert_document_parse_failed') || 'æ–‡æ¡£è§£æå¤±è´¥: ';
                    alert(parseFailedText + error.message);
                }
            }
            
            isSupportedFormat(file) {
                const supportedTypes = [
                    'application/pdf',
                    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                    'application/msword',
                    'text/plain',
                    'text/rtf',
                    'text/html'
                ];
                
                return supportedTypes.includes(file.type) || 
                       file.name.toLowerCase().match(/\.(pdf|docx?|txt|rtf|html?)$/);
            }
            
            async parseDocument(file) {
                const fileType = file.type || this.getFileTypeFromName(file.name);
                
                if (fileType.includes('pdf')) {
                    await this.parsePDF(file);
                } else if (fileType.includes('text') || file.name.endsWith('.txt')) {
                    await this.parseTextFile(file);
                } else if (fileType.includes('html')) {
                    await this.parseHTMLFile(file);
                } else {
                    // å¯¹äºå…¶ä»–æ ¼å¼ï¼Œæ˜¾ç¤ºåŸºæœ¬ä¿¡æ¯
                    const docTypeText = getI18nText('text_document_type') || 'æ–‡æ¡£ç±»å‹';
                    const fileSizeText = getI18nText('text_file_size') || 'æ–‡ä»¶å¤§å°';
                    this.documentContent = `${docTypeText}: ${fileType}\n${fileSizeText}: ${this.formatFileSize(file.size)}`;
                    this.totalPages = 1;
                    this.updatePreview();
                }
            }
            
            async parsePDF(file) {
                try {
                    const pdfLoadingText = getI18nText('text_pdf_loading') || 'PDFæ–‡æ¡£å·²åŠ è½½ï¼Œæ­£åœ¨è§£æ...';
                    this.documentContent = pdfLoadingText;
                    this.updatePreview();
                    
                    // ä½¿ç”¨PDF.jsè§£æPDF
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                    
                    this.totalPages = pdf.numPages;
                    this.pdfDocument = pdf; // ä¿å­˜PDFæ–‡æ¡£å¯¹è±¡
                    
                    // æ¸²æŸ“ç¬¬ä¸€é¡µä½œä¸ºé¢„è§ˆ
                    await this.renderPDFPage(1);
                    
                    console.log('âœ… PDFè§£ææˆåŠŸï¼Œé¡µæ•°:', this.totalPages);
                } catch (error) {
                    console.error('PDFè§£æå¤±è´¥:', error);
                    this.documentContent = `PDFè§£æå¤±è´¥: ${error.message}`;
                    this.totalPages = 0;
                    this.updatePreview();
                }
            }
            
            async renderPDFPage(pageNumber) {
                if (!this.pdfDocument) return;
                
                try {
                    const page = await this.pdfDocument.getPage(pageNumber);
                    
                    // æå–æ–‡æœ¬å†…å®¹
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    
                    // æ›´æ–°å½“å‰é¡µå†…å®¹
                    this.documentContent = pageText || `PDFç¬¬${pageNumber}é¡µ - æ— æ³•æå–æ–‡æœ¬å†…å®¹`;
                    this.currentPage = pageNumber;
                    this.updatePreview();
                    
                    // å¯é€‰ï¼šæ¸²æŸ“PDFé¡µé¢åˆ°canvas
                    const viewport = page.getViewport({ scale: 1.0 });
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    
                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;
                    
                    // å°†canvasæ·»åŠ åˆ°é¢„è§ˆåŒºåŸŸ
                    const previewArea = document.getElementById('previewArea');
                    previewArea.innerHTML = '';
                    previewArea.appendChild(canvas);
                    canvas.style.maxWidth = '100%';
                    canvas.style.height = 'auto';
                    
                } catch (error) {
                    console.error('PDFé¡µé¢æ¸²æŸ“å¤±è´¥:', error);
                    this.documentContent = `ç¬¬${pageNumber}é¡µæ¸²æŸ“å¤±è´¥: ${error.message}`;
                    this.updatePreview();
                }
            }
            
            async parseTextFile(file) {
                const text = await file.text();
                this.documentContent = text;
                this.totalPages = Math.ceil(text.length / 2000); // æ¯2000å­—ç¬¦ç®—ä¸€é¡µ
                this.updatePreview();
            }
            
            async parseHTMLFile(file) {
                const html = await file.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                this.documentContent = doc.body.textContent || doc.body.innerText || html;
                this.totalPages = 1;
                this.updatePreview();
            }
            
            getFileTypeFromName(fileName) {
                const ext = fileName.toLowerCase().split('.').pop();
                const typeMap = {
                    'pdf': 'application/pdf',
                    'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                    'doc': 'application/msword',
                    'txt': 'text/plain',
                    'rtf': 'text/rtf',
                    'html': 'text/html',
                    'htm': 'text/html'
                };
                return typeMap[ext] || 'application/octet-stream';
            }
            
            updateDocumentInfo() {
                const fileName = this.documentFile.name;
                const fileSize = this.formatFileSize(this.documentFile.size);
                
                document.getElementById('documentFileName').textContent = fileName;
                document.getElementById('documentFileInfo').textContent = fileSize;
            }
            
            updatePreview() {
                const previewArea = document.getElementById('previewArea');
                const noPreviewText = getI18nText('text_no_preview_available') || 'æ— æ³•é¢„è§ˆæ­¤æ–‡æ¡£å†…å®¹';
                const content = this.documentContent || noPreviewText;
                
                // ç®€å•çš„åˆ†é¡µæ˜¾ç¤º
                const wordsPerPage = 500;
                const words = content.split(' ');
                const startIndex = (this.currentPage - 1) * wordsPerPage;
                const endIndex = Math.min(startIndex + wordsPerPage, words.length);
                const pageContent = words.slice(startIndex, endIndex).join(' ');
                
                previewArea.innerHTML = `<pre style="white-space: pre-wrap; font-family: inherit;">${pageContent}</pre>`;
                
                // æ›´æ–°é¡µé¢ä¿¡æ¯
                const pageInfoText = getI18nText('text_page_format') || 'é¡µé¢: {current} / {total}';
                document.getElementById('documentPageInfo').textContent = pageInfoText.replace('{current}', this.currentPage).replace('{total}', this.totalPages);
                document.getElementById('currentPageInput').value = this.currentPage;
                document.getElementById('currentPageInput').max = this.totalPages;
                
                // æ›´æ–°é¡µé¢æ§åˆ¶æŒ‰é’®çŠ¶æ€
                document.getElementById('firstPageBtn').disabled = this.currentPage <= 1;
                document.getElementById('prevPageBtn').disabled = this.currentPage <= 1;
                document.getElementById('nextPageBtn').disabled = this.currentPage >= this.totalPages;
                document.getElementById('lastPageBtn').disabled = this.currentPage >= this.totalPages;
                
                // æ›´æ–°æå–è®¾ç½®çš„é»˜è®¤å€¼
                document.getElementById('extractEndPage').value = this.totalPages;
                document.getElementById('extractEndPage').max = this.totalPages;
            }
            
            async goToPage(pageNum) {
                if (pageNum >= 1 && pageNum <= this.totalPages) {
                    this.currentPage = pageNum;
                    
                    if (this.pdfDocument) {
                        // å¦‚æœæ˜¯PDFæ–‡æ¡£ï¼Œé‡æ–°æ¸²æŸ“æŒ‡å®šé¡µé¢
                        await this.renderPDFPage(pageNum);
                    } else {
                        // å¯¹äºå…¶ä»–æ–‡æ¡£ç±»å‹ï¼Œä½¿ç”¨åŸæœ‰çš„åˆ†é¡µé€»è¾‘
                        this.updatePreview();
                    }
                }
            }
            
            zoom(factor) {
                this.zoomLevel = Math.max(50, Math.min(200, this.zoomLevel * factor));
                document.getElementById('zoomLevel').textContent = Math.round(this.zoomLevel) + '%';
                
                const previewArea = document.getElementById('previewArea');
                previewArea.style.fontSize = (14 * this.zoomLevel / 100) + 'px';
            }
            
            showWorkspace() {
                document.getElementById('uploadArea').style.display = 'none';
                document.getElementById('processingWorkspace').style.display = 'block';
            }
            
            switchTab(tabName) {
                document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                
                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
                document.getElementById(`${tabName}Tab`).classList.add('active');
                
                this.currentTab = tabName;
                this.enableProcessButton();
            }
            
            enableProcessButton() {
                const processBtn = document.getElementById('processBtn');
                
                if (!this.documentFile) {
                    processBtn.disabled = true;
                    return;
                }
                
                switch (this.currentTab) {
                    case 'extract':
                        processBtn.disabled = false;
                        break;
                    case 'split':
                        processBtn.disabled = false;
                        break;
                    case 'merge':
                        processBtn.disabled = this.mergeFiles.length < 2;
                        break;
                    case 'convert':
                        const outputFormat = document.getElementById('outputFormat').value;
                        processBtn.disabled = !outputFormat;
                        break;
                    default:
                        processBtn.disabled = true;
                }
            }
            
            setExtractAllPages() {
                document.getElementById('extractStartPage').value = 1;
                document.getElementById('extractEndPage').value = this.totalPages;
            }
            
            updateSplitSettings(method) {
                const intervalSetting = document.getElementById('intervalSetting');
                const pageRangesSetting = document.getElementById('pageRangesSetting');
                
                intervalSetting.style.display = method === 'interval' ? 'block' : 'none';
                pageRangesSetting.style.display = method === 'pages' ? 'block' : 'none';
            }
            
            addMergeFiles(files) {
                Array.from(files).forEach(file => {
                    if (file.type === 'application/pdf') {
                        this.mergeFiles.push(file);
                    }
                });
                
                this.updateMergeFilesList();
                this.enableProcessButton();
            }
            
            updateMergeFilesList() {
                const list = document.getElementById('mergeFilesList');
                list.innerHTML = '';
                
                this.mergeFiles.forEach((file, index) => {
                    const item = document.createElement('div');
                    item.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 8px; background: var(--surface-color); border-radius: 4px; margin-bottom: 8px;';
                    item.innerHTML = `
                        <span>${file.name}</span>
                        <button onclick="documentProcessor.removeMergeFile(${index})" style="background: var(--error-color); color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer;">åˆ é™¤</button>
                    `;
                    list.appendChild(item);
                });
            }
            
            removeMergeFile(index) {
                this.mergeFiles.splice(index, 1);
                this.updateMergeFilesList();
                this.enableProcessButton();
            }
            
            updateConvertSettings(format) {
                const imageQualitySetting = document.getElementById('imageQualitySetting');
                const imageDpiSetting = document.getElementById('imageDpiSetting');
                
                const showImageSettings = format === 'images';
                imageQualitySetting.style.display = showImageSettings ? 'block' : 'none';
                imageDpiSetting.style.display = showImageSettings ? 'block' : 'none';
            }
            
            async processDocument() {
                if (!this.documentFile) return;
                
                document.getElementById('progressSection').style.display = 'block';
                document.getElementById('processBtn').disabled = true;
                
                const startTime = Date.now();
                
                try {
                    this.processedFiles = [];
                    
                    switch (this.currentTab) {
                        case 'extract':
                            await this.extractText();
                            break;
                        case 'split':
                            await this.splitDocument();
                            break;
                        case 'merge':
                            await this.mergeDocuments();
                            break;
                        case 'convert':
                            await this.convertDocument();
                            break;
                    }
                    
                    if (this.processedFiles.length > 0 || this.currentTab === 'extract') {
                        this.showResults(startTime);
                    }
                } catch (error) {
                    console.error('æ–‡æ¡£å¤„ç†å¤±è´¥:', error);
                    const processingFailedText = getI18nText('alert_processing_failed') || 'å¤„ç†å¤±è´¥: ';
                    alert(processingFailedText + error.message);
                } finally {
                    document.getElementById('processBtn').disabled = false;
                }
            }
            
            async extractText() {
                const extractingText = getI18nText('progress_extracting_text') || 'æ­£åœ¨æå–æ–‡æœ¬...';
                this.updateProgress(30, extractingText);
                
                const startPage = parseInt(document.getElementById('extractStartPage').value) || 1;
                const endPage = parseInt(document.getElementById('extractEndPage').value) || this.totalPages;
                const preserveFormatting = document.getElementById('preserveFormatting').checked;
                const removeBlankLines = document.getElementById('removeBlankLines').checked;
                const extractImages = document.getElementById('extractImages').checked;
                
                let extractedText = '';
                let imageLinks = [];
                
                try {
                    if (this.pdfDocument) {
                        // çœŸæ­£çš„PDFæ–‡æœ¬æå–
                        const totalPages = Math.min(endPage, this.totalPages);
                        
                        for (let pageNum = startPage; pageNum <= totalPages; pageNum++) {
                            this.updateProgress(30 + (pageNum - startPage) / (totalPages - startPage + 1) * 60, 
                                             getI18nText('progress_extracting_page') ? getI18nText('progress_extracting_page').replace('{pageNum}', pageNum) : `æ­£åœ¨æå–ç¬¬ ${pageNum} é¡µ...`);
                            
                            try {
                                const page = await this.pdfDocument.getPage(pageNum);
                                
                                // æå–æ–‡æœ¬å†…å®¹
                                const textContent = await page.getTextContent();
                                let pageText = '';
                                
                                if (preserveFormatting) {
                                    // ä¿æŒæ ¼å¼ï¼šè€ƒè™‘æ–‡æœ¬ä½ç½®ä¿¡æ¯
                                    let lastY = null;
                                    textContent.items.forEach(item => {
                                        if (lastY !== null && Math.abs(item.transform[5] - lastY) > 5) {
                                            pageText += '\n';
                                        }
                                        pageText += item.str;
                                        if (item.str.endsWith(' ') === false && item.hasEOL === false) {
                                            pageText += ' ';
                                        }
                                        lastY = item.transform[5];
                                    });
                                } else {
                                    // ç®€å•æ–‡æœ¬æå–
                                    pageText = textContent.items.map(item => item.str).join(' ');
                                }
                                
                                if (pageText.trim()) {
                                    if (extractedText && !extractedText.endsWith('\n\n')) {
                                        extractedText += '\n\n';
                                    }
                                    extractedText += `=== ç¬¬ ${pageNum} é¡µ ===\n`;
                                    extractedText += pageText.trim() + '\n';
                                }
                                
                                // æå–å›¾ç‰‡ä¿¡æ¯ï¼ˆå¦‚æœé€‰æ‹©äº†æ­¤é€‰é¡¹ï¼‰
                                if (extractImages) {
                                    try {
                                        const operatorList = await page.getOperatorList();
                                        let imageCount = 0;
                                        for (let i = 0; i < operatorList.fnArray.length; i++) {
                                            if (operatorList.fnArray[i] === pdfjsLib.OPS.paintImageXObject) {
                                                imageCount++;
                                                imageLinks.push(`[å›¾ç‰‡ ${pageNum}-${imageCount}] ä½äºç¬¬ ${pageNum} é¡µ`);
                                            }
                                        }
                                    } catch (imgError) {
                                        console.warn('æå–å›¾ç‰‡ä¿¡æ¯å¤±è´¥:', imgError);
                                    }
                                }
                                
                            } catch (pageError) {
                                console.error(`ç¬¬${pageNum}é¡µæå–å¤±è´¥:`, pageError);
                                extractedText += `\n=== ç¬¬ ${pageNum} é¡µ ===\n[é¡µé¢æå–å¤±è´¥: ${pageError.message}]\n`;
                            }
                        }
                    } else {
                        // éPDFæ–‡æ¡£ä½¿ç”¨åŸæœ‰é€»è¾‘
                        extractedText = this.documentContent || "æ— æ³•æå–æ–‡æœ¬å†…å®¹";
                    }
                    
                    // åå¤„ç†
                    if (removeBlankLines && extractedText) {
                        extractedText = extractedText.replace(/\n\s*\n\s*\n/g, '\n\n');
                    }
                    
                    // æ·»åŠ å›¾ç‰‡é“¾æ¥ä¿¡æ¯
                    if (imageLinks.length > 0) {
                        const foundImagesText = getI18nText('text_found_images') || '=== å‘ç°çš„å›¾ç‰‡ ===';
                        extractedText += `\n\n${foundImagesText}\n`;
                        extractedText += imageLinks.join('\n');
                    }
                    
                    if (!extractedText.trim()) {
                        const noTextExtractedText = getI18nText('text_no_text_extracted') || 'æœªèƒ½æå–åˆ°æ–‡æœ¬å†…å®¹ã€‚è¿™å¯èƒ½æ˜¯ä¸€ä¸ªå›¾ç‰‡å‹PDFæˆ–æ‰«ææ–‡æ¡£ã€‚';
                        extractedText = noTextExtractedText;
                    }
                    
                    const extractionCompleteText = getI18nText('progress_extraction_complete') || 'æ–‡æœ¬æå–å®Œæˆï¼';
                    this.updateProgress(100, extractionCompleteText);
                    
                } catch (error) {
                    console.error('æ–‡æœ¬æå–å¤±è´¥:', error);
                    const extractionFailedText = getI18nText('text_extraction_failed') || 'æ–‡æœ¬æå–å¤±è´¥';
                    extractedText = `${extractionFailedText}: ${error.message}`;
                    const extractionFailedProgressText = getI18nText('progress_extraction_failed') || 'æå–å¤±è´¥ï¼';
                    this.updateProgress(100, extractionFailedProgressText);
                }
                
                // æ˜¾ç¤ºæå–ç»“æœ
                document.getElementById('extractedText').textContent = extractedText;
                document.getElementById('extractedTextArea').style.display = 'block';
            }
            
            async splitDocument() {
                const splittingText = getI18nText('progress_splitting_document') || 'æ­£åœ¨æ‹†åˆ†æ–‡æ¡£...';
                this.updateProgress(30, splittingText);
                
                const method = document.getElementById('splitMethod').value;
                let fileCount = 1;
                
                if (method === 'interval') {
                    const interval = parseInt(document.getElementById('splitInterval').value) || 10;
                    fileCount = Math.ceil(this.totalPages / interval);
                } else if (method === 'pages') {
                    const ranges = document.getElementById('pageRanges').value;
                    fileCount = ranges.split(',').length;
                }
                
                // æ¨¡æ‹Ÿæ–‡æ¡£æ‹†åˆ†
                for (let i = 0; i < fileCount; i++) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    const creatingDocText = getI18nText('progress_creating_document') ? getI18nText('progress_creating_document').replace('{num}', i + 1) : `æ­£åœ¨åˆ›å»ºç¬¬ ${i + 1} ä¸ªæ–‡æ¡£...`;
                    this.updateProgress(30 + (i + 1) / fileCount * 60, creatingDocText);
                    
                    // åˆ›å»ºæ¨¡æ‹Ÿæ–‡ä»¶
                    const fileName = this.documentFile.name.replace(/\.[^.]+$/, `_part${i + 1}.pdf`);
                    const simulatedPdfContent = getI18nText('text_simulated_pdf_content') || 'æ¨¡æ‹ŸPDFå†…å®¹';
                    const blob = new Blob([simulatedPdfContent], { type: 'application/pdf' });
                    this.processedFiles.push(new File([blob], fileName, { type: 'application/pdf' }));
                }
                
                const splittingCompleteText = getI18nText('progress_splitting_complete') || 'æ–‡æ¡£æ‹†åˆ†å®Œæˆï¼';
                this.updateProgress(100, splittingCompleteText);
            }
            
            async mergeDocuments() {
                const mergingText = getI18nText('progress_merging_documents') || 'æ­£åœ¨åˆå¹¶æ–‡æ¡£...';
                this.updateProgress(30, mergingText);
                
                // æ¨¡æ‹Ÿæ–‡æ¡£åˆå¹¶
                for (let i = 0; i < this.mergeFiles.length; i++) {
                    await new Promise(resolve => setTimeout(resolve, 300));
                    const processingDocText = getI18nText('progress_processing_document') ? getI18nText('progress_processing_document').replace('{num}', i + 1) : `æ­£åœ¨å¤„ç†ç¬¬ ${i + 1} ä¸ªæ–‡æ¡£...`;
                    this.updateProgress(30 + (i + 1) / this.mergeFiles.length * 60, processingDocText);
                }
                
                // åˆ›å»ºåˆå¹¶åçš„æ–‡ä»¶
                const mergedFileName = 'merged_document.pdf';
                const mergedPdfContent = getI18nText('text_merged_pdf_content') || 'åˆå¹¶åçš„PDFå†…å®¹';
                const blob = new Blob([mergedPdfContent], { type: 'application/pdf' });
                this.processedFiles.push(new File([blob], mergedFileName, { type: 'application/pdf' }));
                
                const mergingCompleteText = getI18nText('progress_merging_complete') || 'æ–‡æ¡£åˆå¹¶å®Œæˆï¼';
                this.updateProgress(100, mergingCompleteText);
            }
            
            async convertDocument() {
                const outputFormat = document.getElementById('outputFormat').value;
                const convertingToText = getI18nText('progress_converting_to') ? getI18nText('progress_converting_to').replace('{format}', outputFormat.toUpperCase()) : `æ­£åœ¨è½¬æ¢ä¸º ${outputFormat.toUpperCase()}...`;
                this.updateProgress(30, convertingToText);
                
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                let fileName = this.documentFile.name.replace(/\.[^.]+$/, '');
                let mimeType = 'application/octet-stream';
                let content = getI18nText('text_converted_document_content') || 'è½¬æ¢åçš„æ–‡æ¡£å†…å®¹';
                
                switch (outputFormat) {
                    case 'pdf':
                        fileName += '.pdf';
                        mimeType = 'application/pdf';
                        break;
                    case 'docx':
                        fileName += '.docx';
                        mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
                        break;
                    case 'txt':
                        fileName += '.txt';
                        mimeType = 'text/plain';
                        const convertedTextContent = getI18nText('text_converted_text_content') || 'è½¬æ¢åçš„æ–‡æœ¬å†…å®¹';
                        content = this.documentContent || convertedTextContent;
                        break;
                    case 'html':
                        fileName += '.html';
                        mimeType = 'text/html';
                        const convertedHtmlContent = getI18nText('text_converted_html_content') || 'è½¬æ¢åçš„HTMLå†…å®¹';
                        content = `<html><body><p>${this.documentContent || convertedHtmlContent}</p></body></html>`;
                        break;
                    case 'images':
                        // å¯¹äºå›¾ç‰‡ï¼Œåˆ›å»ºå¤šä¸ªæ–‡ä»¶
                        for (let i = 1; i <= this.totalPages; i++) {
                            const imageFileName = `${fileName}_page${i}.jpg`;
                            const simulatedImageContent = getI18nText('text_simulated_image_content') || 'æ¨¡æ‹Ÿå›¾ç‰‡å†…å®¹';
                            const blob = new Blob([simulatedImageContent], { type: 'image/jpeg' });
                            this.processedFiles.push(new File([blob], imageFileName, { type: 'image/jpeg' }));
                        }
                        const conversionCompleteText = getI18nText('progress_conversion_complete') || 'æ ¼å¼è½¬æ¢å®Œæˆï¼';
                        this.updateProgress(100, conversionCompleteText);
                        return;
                }
                
                const blob = new Blob([content], { type: mimeType });
                this.processedFiles.push(new File([blob], fileName, { type: mimeType }));
                
                const conversionCompleteText2 = getI18nText('progress_conversion_complete') || 'æ ¼å¼è½¬æ¢å®Œæˆï¼';
                this.updateProgress(100, conversionCompleteText2);
            }
            
            showResults(startTime) {
                const processingTime = ((Date.now() - startTime) / 1000).toFixed(1);
                const originalSize = this.documentFile.size;
                let totalResultSize = 0;
                
                this.processedFiles.forEach(file => {
                    totalResultSize += file.size;
                });
                
                document.getElementById('originalFileSize').textContent = this.formatFileSize(originalSize);
                document.getElementById('resultFileSize').textContent = this.formatFileSize(totalResultSize);
                document.getElementById('pageCount').textContent = this.totalPages;
                document.getElementById('processingTime').textContent = processingTime + 's';
                
                // æ˜¾ç¤ºç»“æœæ–‡ä»¶åˆ—è¡¨
                this.updateResultFilesList();
                
                document.getElementById('resultSection').style.display = 'block';
                document.getElementById('resultSection').scrollIntoView({ behavior: 'smooth' });
            }
            
            updateResultFilesList() {
                const list = document.getElementById('resultFilesList');
                list.innerHTML = '';
                
                this.processedFiles.forEach((file, index) => {
                    const item = document.createElement('div');
                    item.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 12px; background: var(--bg-color-secondary); border-radius: 6px; margin-bottom: 10px;';
                    item.innerHTML = `
                        <div>
                            <strong>${file.name}</strong><br>
                            <small style="color: var(--text-secondary);">${this.formatFileSize(file.size)} â€¢ ${file.type}</small>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button onclick="documentProcessor.downloadFile(${index})" class="page-btn" data-i18n="btn_download">ä¸‹è½½</button>
                            <button onclick="documentProcessor.shareFile(${index})" class="page-btn" data-i18n="btn_share">åˆ†äº«</button>
                        </div>
                    `;
                    list.appendChild(item);
                });
            }
            
            downloadFile(index) {
                const file = this.processedFiles[index];
                const url = URL.createObjectURL(file);
                const a = document.createElement('a');
                a.href = url;
                a.download = file.name;
                a.click();
                URL.revokeObjectURL(url);
            }
            
            shareFile(index) {
                const file = this.processedFiles[index];
                
                if (window.ui && window.ui.filesQueue) {
                    window.ui.filesQueue.push(file);
                    const fileAddedToShareText = getI18nText('alert_file_added_to_share') || 'å·²æ·»åŠ åˆ°åˆ†äº«åˆ—è¡¨ï¼';
                    alert(`${file.name} ${fileAddedToShareText}`);
                } else {
                    const shareUnavailableText = getI18nText('alert_share_unavailable') || 'åˆ†äº«åŠŸèƒ½æš‚ä¸å¯ç”¨ï¼Œè¯·å…ˆè¿”å›åˆ†äº«é¡µé¢';
                    alert(shareUnavailableText);
                }
            }
            
            downloadAllFiles() {
                this.processedFiles.forEach((file, index) => {
                    setTimeout(() => this.downloadFile(index), index * 500);
                });
            }
            
            shareAllFiles() {
                if (window.ui && window.ui.filesQueue) {
                    this.processedFiles.forEach(file => {
                        window.ui.filesQueue.push(file);
                    });
                    const filesAddedToShareText = getI18nText('alert_files_added_to_share') || 'ä¸ªæ–‡ä»¶å·²æ·»åŠ åˆ°åˆ†äº«åˆ—è¡¨ï¼';
                    alert(`${this.processedFiles.length} ${filesAddedToShareText}`);
                } else {
                    const shareUnavailableText2 = getI18nText('alert_share_unavailable') || 'åˆ†äº«åŠŸèƒ½æš‚ä¸å¯ç”¨ï¼Œè¯·å…ˆè¿”å›åˆ†äº«é¡µé¢';
                    alert(shareUnavailableText2);
                }
            }
            
            copyExtractedText() {
                const text = document.getElementById('extractedText').textContent;
                navigator.clipboard.writeText(text).then(() => {
                    const textCopiedText = getI18nText('alert_text_copied') || 'æ–‡æœ¬å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼';
                    alert(textCopiedText);
                }).catch(err => {
                    console.error('å¤åˆ¶å¤±è´¥:', err);
                    const copyFailedText = getI18nText('alert_copy_failed') || 'å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©æ–‡æœ¬å¤åˆ¶';
                    alert(copyFailedText);
                });
            }
            
            updateProgress(percent, text) {
                document.getElementById('progressFill').style.width = percent + '%';
                document.getElementById('progressText').textContent = text;
            }
            
            formatFileSize(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            resetSettings() {
                // é‡ç½®æ‰€æœ‰è®¾ç½®åˆ°é»˜è®¤å€¼
                document.getElementById('extractStartPage').value = 1;
                document.getElementById('extractEndPage').value = this.totalPages;
                document.getElementById('splitMethod').value = 'pages';
                document.getElementById('splitInterval').value = 10;
                document.getElementById('outputFormat').value = 'pdf';
                // ... é‡ç½®å…¶ä»–è®¾ç½®
                
                this.updateSplitSettings('pages');
                this.updateConvertSettings('pdf');
            }
            
            selectNewFile() {
                document.getElementById('fileInput').click();
            }
            
            processAnother() {
                document.getElementById('resultSection').style.display = 'none';
                document.getElementById('progressSection').style.display = 'none';
                document.getElementById('extractedTextArea').style.display = 'none';
                this.processedFiles = [];
                this.resetSettings();
            }
        }
        
        // åˆå§‹åŒ–
        let documentProcessor;
        document.addEventListener('DOMContentLoaded', () => {
            documentProcessor = new DocumentProcessor();
            // Initialize i18n after document processor
            if (typeof initializeI18n === 'function') {
                initializeI18n();
            }
        });
    </script>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-analytics-compat.js"></script>
    
    <!-- Firebase Analytics Configuration -->
    <script src="scripts/firebase-analytics.js"></script>
    <script src="scripts/analytics-enhanced.js"></script>
    <script src="scripts/tools-analytics.js"></script>
    
    <!-- Load i18n system -->
    <script src="scripts/i18n/languages.js"></script>
    <script>
        // Initialize the i18n system
        function initializeI18n() {
            // Get user language preference
            const userLanguage = getUserLanguage();
            
            // Set initial language
            setLanguage(userLanguage);
            
            // Update language selector
            const languageSelector = document.getElementById('language-selector');
            if (languageSelector) {
                languageSelector.value = userLanguage;
                languageSelector.addEventListener('change', (e) => {
                    setLanguage(e.target.value);
                });
            }
        }
    </script>
</body>
</html>