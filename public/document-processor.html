<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="document_processor_title">Document Processor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #333;
            line-height: 1.6;
        }

        .header {
            background: white;
            border-bottom: 1px solid #e5e7eb;
            padding: 12px 0;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 20px;
            font-weight: bold;
            color: #3367d6;
            text-decoration: none;
        }

        .nav-links {
            display: flex;
            gap: 16px;
        }
        
        .nav-links a {
            color: #6b7280;
            text-decoration: none;
            font-weight: 500;
            font-size: 14px;
            padding: 6px 12px;
            border-radius: 6px;
            transition: all 0.2s ease;
        }
        
        .nav-links a:hover {
            color: #3367d6;
            background: #f3f4f6;
        }
        
        .nav-links a.active {
            color: #3367d6;
            background: #e3f2fd;
            font-weight: 600;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .page-title {
            font-size: 32px;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 8px;
            text-align: center;
        }

        .page-subtitle {
            font-size: 16px;
            color: #6b7280;
            text-align: center;
            margin-bottom: 40px;
        }
        
        
        .processor-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 30px;
            margin-bottom: 30px;
        }
        
        .upload-area {
            border: 3px dashed #d1d5db;
            border-radius: 12px;
            padding: 60px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f9fafb;
            margin-bottom: 30px;
        }
        
        .upload-area:hover, .upload-area.dragover {
            border-color: #3367d6;
            background: #eff6ff;
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 16px;
            color: #9ca3af;
        }

        .upload-text {
            font-size: 18px;
            color: #374151;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .upload-hint {
            font-size: 14px;
            color: #6b7280;
        }

        #fileInput {
            display: none;
        }
        
        .processing-workspace {
            display: none;
        }
        
        .tabs {
            display: flex;
            gap: 0;
            margin-bottom: 20px;
            background: #f3f4f6;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .tab {
            flex: 1;
            padding: 12px 20px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
            color: #6b7280;
        }
        
        .tab.active {
            background: #3367d6;
            color: white;
        }
        
        .tab-content {
            display: none;
            padding: 20px;
            background: #f9fafb;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .document-preview {
            width: 100%;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            max-height: 500px;
            border: 1px solid #e5e7eb;
        }
        
        .preview-header {
            padding: 15px 20px;
            background: #3367d6;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .document-info h4 {
            margin: 0 0 4px 0;
            font-size: 16px;
        }
        
        .document-info p {
            margin: 0;
            font-size: 12px;
            opacity: 0.8;
        }
        
        .preview-controls {
            padding: 15px 20px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            gap: 15px;
            background: #f9fafb;
        }
        
        .preview-area {
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .page-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .page-btn {
            padding: 6px 12px;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        .page-btn:hover {
            background: #3367d6;
            color: white;
            border-color: #3367d6;
        }
        
        .page-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .page-input {
            width: 60px;
            padding: 4px 8px;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            text-align: center;
            font-size: 12px;
        }
        
        .tool-group {
            background: #f9fafb;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            margin-bottom: 15px;
        }
        
        .tool-group h4 {
            margin-bottom: 15px;
            color: #374151;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }
        
        .settings-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        
        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .setting-item label {
            font-weight: 500;
            color: #374151;
            font-size: 14px;
        }
        
        .setting-item input, .setting-item select {
            padding: 8px 12px;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            background: white;
            color: #374151;
            font-size: 14px;
        }
        
        .range-input {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .range-input input[type="range"] {
            flex: 1;
        }
        
        .range-value {
            min-width: 40px;
            text-align: center;
            font-weight: 500;
            color: #3367d6;
        }
        
        .page-range {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }
        
        .page-range input {
            width: 60px;
        }
        
        .process-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 30px 0;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 16px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: #3367d6;
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            background: #2563eb;
            transform: translateY(-1px);
        }
        
        .btn-primary:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-secondary {
            background: #6b7280;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #4b5563;
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn-success:hover {
            background: #059669;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 15px 0;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .text-extraction-result {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 13px;
            line-height: 1.5;
        }
        
        .progress-section {
            display: none;
            margin: 20px 0;
            padding: 20px;
            background: #f9fafb;
            border-radius: 8px;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #f3f4f6;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: #3367d6;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .result-section {
            display: none;
            margin-top: 30px;
            padding: 20px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background: #f0f9ff;
            border: 1px solid #bae6fd;
        }
        
        .result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-item {
            text-align: center;
            padding: 15px;
            background: #f9fafb;
            border-radius: 8px;
        }
        
        .stat-label {
            display: block;
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 4px;
            text-transform: uppercase;
            font-weight: 500;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: 600;
            color: #374151;
        }
        
        @media (max-width: 768px) {
            .nav-links {
                display: none;
            }

            .container {
                padding: 20px 16px;
            }

            .processor-card {
                padding: 20px;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .settings-panel {
                grid-template-columns: 1fr;
            }
            
            .process-actions {
                flex-direction: column;
            }
            
            .process-actions .btn {
                width: 100%;
            }
            
            .result-stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>

    <link rel="stylesheet" href="share-integration.css">
    <link rel="stylesheet" href="device-selector.css">
    <script src="/locales/i18n.js"></script>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-container">
            <a href="/" class="logo">
                <svg viewBox="0 0 24 24" style="width: 32px; height: 32px; margin-right: 8px; fill: #3367d6;">
                    <path d="M12 11c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 2c0-3.31-2.69-6-6-6s-6 2.69-6 6c0 2.22 1.21 4.15 3 5.19l1-1.74c-1.19-.7-2-1.97-2-3.45 0-2.21 1.79-4 4-4s4 1.79 4 4c0 1.48-.81 2.75-2 3.45l1 1.74c1.79-1.04 3-2.97 3-5.19zM12 3C6.48 3 2 7.48 2 13c0 3.7 2.01 6.92 4.99 8.65l1-1.73C5.61 18.53 4 15.96 4 13c0-4.42 3.58-8 8-8s8 3.58 8 8c0 2.96-1.61 5.53-4 6.92l1 1.73c2.99-1.73 5-4.95 5-8.65 0-5.52-4.48-10-10-10z"/>
                </svg>
                <span data-i18n="site_name">DropShare</span>
            </a>
            <nav class="nav-links">
                <a href="index.html" data-i18n="nav_home">Home</a>
                <a href="share.html" data-i18n="nav_transfer">Transfer</a>
                <a href="share.html#rooms" data-i18n="nav_rooms">Rooms</a>
                <a href="image-tools.html" data-i18n="nav_images">Images</a>
                <a href="audio-tools.html" data-i18n="nav_audio">Audio</a>
                <a href="video-tools.html" data-i18n="nav_video">Video</a>
                <a href="document-tools.html" class="active" data-i18n="nav_files">Files</a>
            </nav>
        </div>
    </header>
    
    <div class="container">
        
        <h1 class="page-title" data-i18n="document_processor_heading">üìÑ Document Processor</h1>
        <p class="page-subtitle" data-i18n="document_processor_subtitle">Process, convert, split, merge, and extract text from documents</p>

        <div class="processor-card">
            <!-- Upload Area -->
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">üìÑ</div>
                <div class="upload-text" data-i18n="document_drop_text">Drop documents here or click to select</div>
                <div class="upload-hint" data-i18n="document_supported_formats">Supports PDF, DOCX, TXT, RTF, HTML formats</div>
                <input type="file" id="fileInput" accept=".pdf,.docx,.txt,.rtf,.html,.doc">
                <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()" style="margin-top: 15px;" data-i18n="select_document_files">
                    Select Document Files
                </button>
            </div>
        
        <div class="processing-workspace" id="processingWorkspace">
            <div class="document-preview">
                <div class="preview-header">
                    <div class="document-info">
                        <h4 id="documentFileName" data-i18n="no_file_selected">No file selected</h4>
                        <p id="documentFileInfo">-</p>
                    </div>
                    <div class="document-actions">
                        <span id="documentPageInfo" data-i18n="page_info_format">Page: - / -</span>
                    </div>
                </div>
                <div class="preview-controls">
                    <div class="page-controls">
                        <button class="page-btn" id="firstPageBtn">‚èÆÔ∏è</button>
                        <button class="page-btn" id="prevPageBtn">‚óÄÔ∏è</button>
                        <input type="number" id="currentPageInput" class="page-input" min="1" value="1">
                        <button class="page-btn" id="nextPageBtn">‚ñ∂Ô∏è</button>
                        <button class="page-btn" id="lastPageBtn">‚è≠Ô∏è</button>
                    </div>
                    <div class="zoom-controls">
                        <button class="page-btn" id="zoomOutBtn">üîç-</button>
                        <span id="zoomLevel">100%</span>
                        <button class="page-btn" id="zoomInBtn">üîç+</button>
                    </div>
                </div>
                <div class="preview-area" id="previewArea">
                    <p style="text-align: center; color: #6b7280; margin: 40px 0;" data-i18n="select_document_to_preview">Select a document file to preview</p>
                </div>
            </div>
            
            <div class="tabs">
                <button class="tab active" data-tab="extract" data-i18n="tab_extract_text">Text Extract</button>
                <button class="tab" data-tab="split" data-i18n="tab_split_document">Split Document</button>
                <button class="tab" data-tab="merge" data-i18n="tab_merge_documents">Merge Documents</button>
                <button class="tab" data-tab="convert" data-i18n="tab_convert_format">Format Convert</button>
            </div>
            
            <!-- ÊñáÊú¨ÊèêÂèñ -->
            <div class="tab-content active" id="extractTab">
                <div class="tool-group">
                    <h4 data-i18n="text_extraction_settings">üìù Text Extraction Settings</h4>
                    <div class="page-range">
                        <label data-i18n="extract_pages">Extract pages:</label>
                        <input type="number" id="extractStartPage" data-i18n-placeholder="start_page" placeholder="Start page" min="1" value="1">
                        <span data-i18n="to">to</span>
                        <input type="number" id="extractEndPage" data-i18n-placeholder="end_page" placeholder="End page" min="1">
                        <button class="page-btn" id="extractAllPagesBtn" data-i18n="all_pages">All Pages</button>
                    </div>
                    
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="preserveFormatting" checked>
                            <label for="preserveFormatting" data-i18n="preserve_formatting">Preserve formatting</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="extractImages">
                            <label for="extractImages" data-i18n="extract_image_links">Extract image links</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="removeBlankLines">
                            <label for="removeBlankLines" data-i18n="remove_blank_lines">Remove blank lines</label>
                        </div>
                    </div>
                </div>
                
                <div id="extractedTextArea" class="text-extraction-result" style="display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <strong data-i18n="extracted_text">Extracted text:</strong>
                        <button class="page-btn" id="copyTextBtn" data-i18n="copy_text">Copy Text</button>
                    </div>
                    <div id="extractedText"></div>
                </div>
            </div>
            
            <!-- Document Split -->
            <div class="tab-content" id="splitTab">
                <div class="tool-group">
                    <h4 data-i18n="document_split_settings">‚úÇÔ∏è Document Split Settings</h4>
                    <div class="settings-panel">
                        <div class="setting-item">
                            <label data-i18n="split_method">Split method:</label>
                            <select id="splitMethod">
                                <option value="pages" data-i18n="by_page_range">By page range</option>
                                <option value="interval" data-i18n="by_interval_pages">By interval pages</option>
                                <option value="bookmarks" data-i18n="by_bookmarks">By bookmarks</option>
                            </select>
                        </div>
                        
                        <div class="setting-item" id="intervalSetting">
                            <label data-i18n="pages_per_file">Pages per file:</label>
                            <input type="number" id="splitInterval" value="10" min="1">
                        </div>
                    </div>
                    
                    <div id="pageRangesSetting" style="display: none;">
                        <label data-i18n="page_ranges_comma">Page ranges (comma separated, e.g., 1-5, 10-15, 20):</label>
                        <input type="text" id="pageRanges" placeholder="1-5, 10-15, 20" style="width: 100%; margin-top: 8px;">
                    </div>
                </div>
            </div>
            
            <!-- Document Merge -->
            <div class="tab-content" id="mergeTab">
                <div class="tool-group">
                    <h4 data-i18n="document_merge_settings">üîó Document Merge Settings</h4>
                    <p style="margin-bottom: 15px; color: #6b7280;" data-i18n="merge_multiple_pdf">
                        Merge multiple PDF documents into one. Please upload multiple files.
                    </p>
                    
                    <div style="margin: 15px 0;">
                        <input type="file" id="mergeFilesInput" accept=".pdf" multiple style="display: none;">
                        <button class="btn btn-secondary" onclick="document.getElementById('mergeFilesInput').click()" data-i18n="select_documents_to_merge">
                            Select Documents to Merge
                        </button>
                    </div>
                    
                    <div id="mergeFilesList" style="margin: 15px 0;"></div>
                    
                    <div class="checkbox-item">
                        <input type="checkbox" id="addBookmarks" checked>
                        <label for="addBookmarks" data-i18n="add_bookmarks_each_doc">Add bookmarks for each document</label>
                    </div>
                </div>
            </div>
            
            <!-- Format Convert -->
            <div class="tab-content" id="convertTab">
                <div class="tool-group">
                    <h4 data-i18n="format_convert_settings">üîÑ Format Convert Settings</h4>
                    <div class="settings-panel">
                        <div class="setting-item">
                            <label data-i18n="output_format">Output format:</label>
                            <select id="outputFormat">
                                <option value="pdf">PDF</option>
                                <option value="docx" data-i18n="word_document">Word Document (.docx)</option>
                                <option value="txt" data-i18n="plain_text">Plain Text (.txt)</option>
                                <option value="html" data-i18n="html_webpage">HTML Webpage</option>
                                <option value="rtf" data-i18n="rtf_document">RTF Document</option>
                                <option value="images" data-i18n="images_jpg_png">Images (JPG/PNG)</option>
                            </select>
                        </div>
                        
                        <div class="setting-item" id="imageQualitySetting" style="display: none;">
                            <label data-i18n="image_quality">Image quality:</label>
                            <div class="range-input">
                                <input type="range" id="imageQuality" min="50" max="100" value="90">
                                <span class="range-value" id="imageQualityValue">90%</span>
                            </div>
                        </div>
                        
                        <div class="setting-item" id="imageDpiSetting" style="display: none;">
                            <label data-i18n="image_dpi">Image DPI:</label>
                            <select id="imageDpi">
                                <option value="72" data-i18n="web_72_dpi">72 DPI (Web)</option>
                                <option value="150" selected data-i18n="standard_150_dpi">150 DPI (Standard)</option>
                                <option value="300" data-i18n="high_quality_300_dpi">300 DPI (High Quality)</option>
                                <option value="600" data-i18n="print_600_dpi">600 DPI (Print)</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="process-actions">
                <button class="btn btn-primary" id="processBtn" disabled data-i18n="start_processing">Start Processing</button>
                <button class="btn btn-secondary" id="resetBtn" data-i18n="reset_settings">Reset Settings</button>
                <button class="btn btn-secondary" id="newFileBtn" data-i18n="select_new_document">Select New Document</button>
            </div>
            
            <div class="progress-section" id="progressSection">
                <h4 data-i18n="processing_progress">Processing Progress:</h4>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div id="progressText" data-i18n="ready_to_process">Ready to process...</div>
            </div>
            
            <div class="result-section" id="resultSection">
                <h3 data-i18n="processing_results">üéâ Processing Results</h3>
                
                <div class="result-stats">
                    <div class="stat-item">
                        <span class="stat-label" data-i18n="original_size">Original Size</span>
                        <span class="stat-value" id="originalFileSize">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label" data-i18n="processed_size">Processed Size</span>
                        <span class="stat-value" id="resultFileSize">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label" data-i18n="page_count">Page Count</span>
                        <span class="stat-value" id="pageCount">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label" data-i18n="processing_time">Processing Time</span>
                        <span class="stat-value" id="processingTime">-</span>
                    </div>
                </div>
                
                <div id="resultFilesList"></div>
                
                <div class="process-actions">
                    <button class="btn btn-success" id="downloadAllBtn" data-i18n="download_all_files">üì• Download All Files</button>
                    <button class="btn btn-secondary" id="shareAllBtn" data-i18n="share_all_files">üì§ Share All Files</button>
                    <button class="btn btn-secondary" id="processAnotherBtn" data-i18n="process_another_document">üîÑ Process Another Document</button>
                </div>
            </div>
        </div>
    </div>

    <!-- PDF.js Library -->
    <script src="https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
    <script>
        // PDF.js worker setup
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js';
        }
    </script>

    <script>
        // ÂõΩÈôÖÂåñËæÖÂä©ÂáΩÊï∞
        function getI18nText(key) {
            if (window.DROPSHARE_I18N && typeof window.DROPSHARE_I18N.getText === 'function') {
                return window.DROPSHARE_I18N.getText(key);
            }
            return null;
        }

        class DocumentProcessor {
            constructor() {
                this.documentFile = null;
                this.currentPage = 1;
                this.totalPages = 0;
                this.zoomLevel = 100;
                this.currentTab = 'extract';
                this.processedFiles = [];
                this.mergeFiles = [];
                this.documentContent = null;
                
                this.init();
            }
            
            init() {
                this.bindEvents();
            }
            
            bindEvents() {
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                
                // ÊãñÊãΩ‰∏ä‰º†
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.loadDocument(files[0]);
                    }
                });
                
                // Êñá‰ª∂ÈÄâÊã©
                fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.loadDocument(e.target.files[0]);
                    }
                });
                
                // Ê†áÁ≠æÂàáÊç¢
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', () => this.switchTab(tab.dataset.tab));
                });
                
                // È°µÈù¢ÂØºËà™
                document.getElementById('firstPageBtn').addEventListener('click', () => this.goToPage(1));
                document.getElementById('prevPageBtn').addEventListener('click', () => this.goToPage(this.currentPage - 1));
                document.getElementById('nextPageBtn').addEventListener('click', () => this.goToPage(this.currentPage + 1));
                document.getElementById('lastPageBtn').addEventListener('click', () => this.goToPage(this.totalPages));
                document.getElementById('currentPageInput').addEventListener('change', (e) => this.goToPage(parseInt(e.target.value)));
                
                // Áº©ÊîæÊéßÂà∂
                document.getElementById('zoomInBtn').addEventListener('click', () => this.zoom(1.2));
                document.getElementById('zoomOutBtn').addEventListener('click', () => this.zoom(0.8));
                
                // Â§ÑÁêÜÊåâÈíÆ
                document.getElementById('processBtn').addEventListener('click', () => this.processDocument());
                document.getElementById('resetBtn').addEventListener('click', () => this.resetSettings());
                document.getElementById('newFileBtn').addEventListener('click', () => this.selectNewFile());
                
                // ÊèêÂèñÊñáÊú¨Áõ∏ÂÖ≥
                document.getElementById('extractAllPagesBtn').addEventListener('click', () => this.setExtractAllPages());
                document.getElementById('copyTextBtn').addEventListener('click', () => this.copyExtractedText());
                
                // ÊãÜÂàÜÊñπÂºèÂàáÊç¢
                document.getElementById('splitMethod').addEventListener('change', (e) => this.updateSplitSettings(e.target.value));
                
                // ÂêàÂπ∂Êñá‰ª∂ÈÄâÊã©
                document.getElementById('mergeFilesInput').addEventListener('change', (e) => this.addMergeFiles(e.target.files));
                
                // ËæìÂá∫Ê†ºÂºèÂàáÊç¢
                document.getElementById('outputFormat').addEventListener('change', (e) => this.updateConvertSettings(e.target.value));
                
                // ÊªëÂùóÁªëÂÆö
                this.bindSliders();
                
                // ÁªìÊûúÊìç‰Ωú
                document.getElementById('downloadAllBtn').addEventListener('click', () => this.downloadAllFiles());
                document.getElementById('shareAllBtn').addEventListener('click', () => this.shareAllFiles());
                document.getElementById('processAnotherBtn').addEventListener('click', () => this.processAnother());
                
                // ÁõëÂê¨ËÆæÁΩÆÂèòÂåñ‰ª•ÂêØÁî®Â§ÑÁêÜÊåâÈíÆ
                this.bindSettingChanges();
            }
            
            bindSliders() {
                const imageQuality = document.getElementById('imageQuality');
                const imageQualityValue = document.getElementById('imageQualityValue');
                
                imageQuality.addEventListener('input', () => {
                    imageQualityValue.textContent = imageQuality.value + '%';
                });
            }
            
            bindSettingChanges() {
                const settings = ['extractStartPage', 'extractEndPage', 'splitInterval', 'pageRanges', 'outputFormat'];
                settings.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('input', () => this.enableProcessButton());
                        element.addEventListener('change', () => this.enableProcessButton());
                    }
                });
            }
            
            async loadDocument(file) {
                if (!this.isSupportedFormat(file)) {
                    const unsupportedFormatText = getI18nText('alert_unsupported_format') || 'Unsupported document format! Please select PDF, DOCX, TXT, RTF or HTML files.';
                    alert(unsupportedFormatText);
                    return;
                }
                
                this.documentFile = file;
                this.updateDocumentInfo();
                
                try {
                    await this.parseDocument(file);
                    this.showWorkspace();
                    this.enableProcessButton();
                } catch (error) {
                    console.error('ÊñáÊ°£Ëß£ÊûêÂ§±Ë¥•:', error);
                    const parseFailedText = getI18nText('alert_parse_failed') || 'Document parsing failed: ';
                    alert(parseFailedText + error.message);
                }
            }
            
            isSupportedFormat(file) {
                const supportedTypes = [
                    'application/pdf',
                    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                    'application/msword',
                    'text/plain',
                    'text/rtf',
                    'text/html'
                ];
                
                return supportedTypes.includes(file.type) || 
                       file.name.toLowerCase().match(/\.(pdf|docx?|txt|rtf|html?)$/);
            }
            
            async parseDocument(file) {
                const fileType = file.type || this.getFileTypeFromName(file.name);
                
                if (fileType.includes('pdf')) {
                    await this.parsePDF(file);
                } else if (fileType.includes('text') || file.name.endsWith('.txt')) {
                    await this.parseTextFile(file);
                } else if (fileType.includes('html')) {
                    await this.parseHTMLFile(file);
                } else {
                    // For other formats, display basic information
                    const docTypeText = getI18nText('text_document_type') || 'Document Type';
                    const fileSizeText = getI18nText('text_file_size') || 'File Size';
                    this.documentContent = `${docTypeText}: ${fileType}\n${fileSizeText}: ${this.formatFileSize(file.size)}`;
                    this.totalPages = 1;
                    this.updatePreview();
                }
            }
            
            async parsePDF(file) {
                try {
                    const pdfLoadingText = getI18nText('text_pdf_loading') || 'PDF document loaded, parsing...';
                    this.documentContent = pdfLoadingText;
                    this.updatePreview();
                    
                    // ‰ΩøÁî®PDF.jsËß£ÊûêPDF
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                    
                    this.totalPages = pdf.numPages;
                    this.pdfDocument = pdf; // ‰øùÂ≠òPDFÊñáÊ°£ÂØπË±°
                    
                    // Ê∏≤ÊüìÁ¨¨‰∏ÄÈ°µ‰Ωú‰∏∫È¢ÑËßà
                    await this.renderPDFPage(1);
                    
                    console.log('‚úÖ PDF parsing successful, pages:', this.totalPages);
                } catch (error) {
                    console.error('PDF parsing failed:', error);
                    this.documentContent = `PDF parsing failed: ${error.message}`;
                    this.totalPages = 0;
                    this.updatePreview();
                }
            }
            
            async renderPDFPage(pageNumber) {
                if (!this.pdfDocument) return;
                
                try {
                    const page = await this.pdfDocument.getPage(pageNumber);
                    
                    // Extract text content
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    
                    // Update current page content
                    this.documentContent = pageText || `PDF page ${pageNumber} - Unable to extract text content`;
                    this.currentPage = pageNumber;
                    this.updatePreview();
                    
                    // Optional: Render PDF page to canvas
                    const viewport = page.getViewport({ scale: 1.0 });
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    
                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;
                    
                    // Add canvas to preview area
                    const previewArea = document.getElementById('previewArea');
                    previewArea.innerHTML = '';
                    previewArea.appendChild(canvas);
                    canvas.style.maxWidth = '100%';
                    canvas.style.height = 'auto';
                    
                } catch (error) {
                    console.error('PDF page rendering failed:', error);
                    this.documentContent = `Page ${pageNumber} rendering failed: ${error.message}`;
                    this.updatePreview();
                }
            }
            
            async parseTextFile(file) {
                const text = await file.text();
                this.documentContent = text;
                this.totalPages = Math.ceil(text.length / 2000); // 2000 characters per page
                this.updatePreview();
            }
            
            async parseHTMLFile(file) {
                const html = await file.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                this.documentContent = doc.body.textContent || doc.body.innerText || html;
                this.totalPages = 1;
                this.updatePreview();
            }
            
            getFileTypeFromName(fileName) {
                const ext = fileName.toLowerCase().split('.').pop();
                const typeMap = {
                    'pdf': 'application/pdf',
                    'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                    'doc': 'application/msword',
                    'txt': 'text/plain',
                    'rtf': 'text/rtf',
                    'html': 'text/html',
                    'htm': 'text/html'
                };
                return typeMap[ext] || 'application/octet-stream';
            }
            
            updateDocumentInfo() {
                const fileName = this.documentFile.name;
                const fileSize = this.formatFileSize(this.documentFile.size);
                
                document.getElementById('documentFileName').textContent = fileName;
                document.getElementById('documentFileInfo').textContent = fileSize;
            }
            
            updatePreview() {
                const previewArea = document.getElementById('previewArea');
                const noPreviewText = getI18nText('text_no_preview') || 'Unable to preview this document content';
                const content = this.documentContent || noPreviewText;
                
                // Simple pagination display
                const wordsPerPage = 500;
                const words = content.split(' ');
                const startIndex = (this.currentPage - 1) * wordsPerPage;
                const endIndex = Math.min(startIndex + wordsPerPage, words.length);
                const pageContent = words.slice(startIndex, endIndex).join(' ');
                
                previewArea.innerHTML = `<pre style="white-space: pre-wrap; font-family: inherit;">${pageContent}</pre>`;
                
                // Update page information
                const pageInfoText = getI18nText('text_page_format') || 'Page: {current} / {total}';
                document.getElementById('documentPageInfo').textContent = pageInfoText.replace('{current}', this.currentPage).replace('{total}', this.totalPages);
                document.getElementById('currentPageInput').value = this.currentPage;
                document.getElementById('currentPageInput').max = this.totalPages;
                
                // Update page control button states
                document.getElementById('firstPageBtn').disabled = this.currentPage <= 1;
                document.getElementById('prevPageBtn').disabled = this.currentPage <= 1;
                document.getElementById('nextPageBtn').disabled = this.currentPage >= this.totalPages;
                document.getElementById('lastPageBtn').disabled = this.currentPage >= this.totalPages;
                
                // Update default values for extraction settings
                document.getElementById('extractEndPage').value = this.totalPages;
                document.getElementById('extractEndPage').max = this.totalPages;
            }
            
            async goToPage(pageNum) {
                if (pageNum >= 1 && pageNum <= this.totalPages) {
                    this.currentPage = pageNum;
                    
                    if (this.pdfDocument) {
                        // If it's a PDF document, re-render the specified page
                        await this.renderPDFPage(pageNum);
                    } else {
                        // For other document types, use the original pagination logic
                        this.updatePreview();
                    }
                }
            }
            
            zoom(factor) {
                this.zoomLevel = Math.max(50, Math.min(200, this.zoomLevel * factor));
                document.getElementById('zoomLevel').textContent = Math.round(this.zoomLevel) + '%';
                
                const previewArea = document.getElementById('previewArea');
                previewArea.style.fontSize = (14 * this.zoomLevel / 100) + 'px';
            }
            
            showWorkspace() {
                document.getElementById('uploadArea').style.display = 'none';
                document.getElementById('processingWorkspace').style.display = 'block';
            }
            
            switchTab(tabName) {
                document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                
                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
                document.getElementById(`${tabName}Tab`).classList.add('active');
                
                this.currentTab = tabName;
                this.enableProcessButton();
            }
            
            enableProcessButton() {
                const processBtn = document.getElementById('processBtn');
                
                if (!this.documentFile) {
                    processBtn.disabled = true;
                    return;
                }
                
                switch (this.currentTab) {
                    case 'extract':
                        processBtn.disabled = false;
                        break;
                    case 'split':
                        processBtn.disabled = false;
                        break;
                    case 'merge':
                        processBtn.disabled = this.mergeFiles.length < 2;
                        break;
                    case 'convert':
                        const outputFormat = document.getElementById('outputFormat').value;
                        processBtn.disabled = !outputFormat;
                        break;
                    default:
                        processBtn.disabled = true;
                }
            }
            
            setExtractAllPages() {
                document.getElementById('extractStartPage').value = 1;
                document.getElementById('extractEndPage').value = this.totalPages;
            }
            
            updateSplitSettings(method) {
                const intervalSetting = document.getElementById('intervalSetting');
                const pageRangesSetting = document.getElementById('pageRangesSetting');
                
                intervalSetting.style.display = method === 'interval' ? 'block' : 'none';
                pageRangesSetting.style.display = method === 'pages' ? 'block' : 'none';
            }
            
            addMergeFiles(files) {
                Array.from(files).forEach(file => {
                    if (file.type === 'application/pdf') {
                        this.mergeFiles.push(file);
                    }
                });
                
                this.updateMergeFilesList();
                this.enableProcessButton();
            }
            
            updateMergeFilesList() {
                const list = document.getElementById('mergeFilesList');
                list.innerHTML = '';
                
                this.mergeFiles.forEach((file, index) => {
                    const item = document.createElement('div');
                    item.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 8px; background: var(--surface-color); border-radius: 4px; margin-bottom: 8px;';
                    item.innerHTML = `
                        <span>${file.name}</span>
                        <button onclick="documentProcessor.removeMergeFile(${index})" style="background: var(--error-color); color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer;">${getI18nText('remove') || 'Remove'}</button>
                    `;
                    list.appendChild(item);
                });
            }
            
            removeMergeFile(index) {
                this.mergeFiles.splice(index, 1);
                this.updateMergeFilesList();
                this.enableProcessButton();
            }
            
            updateConvertSettings(format) {
                const imageQualitySetting = document.getElementById('imageQualitySetting');
                const imageDpiSetting = document.getElementById('imageDpiSetting');
                
                const showImageSettings = format === 'images';
                imageQualitySetting.style.display = showImageSettings ? 'block' : 'none';
                imageDpiSetting.style.display = showImageSettings ? 'block' : 'none';
            }
            
            async processDocument() {
                if (!this.documentFile) return;
                
                document.getElementById('progressSection').style.display = 'block';
                document.getElementById('processBtn').disabled = true;
                
                const startTime = Date.now();
                
                try {
                    this.processedFiles = [];
                    
                    switch (this.currentTab) {
                        case 'extract':
                            await this.extractText();
                            break;
                        case 'split':
                            await this.splitDocument();
                            break;
                        case 'merge':
                            await this.mergeDocuments();
                            break;
                        case 'convert':
                            await this.convertDocument();
                            break;
                    }
                    
                    if (this.processedFiles.length > 0 || this.currentTab === 'extract') {
                        this.showResults(startTime);
                    }
                } catch (error) {
                    console.error('Document processing failed:', error);
                    const processingFailedText = getI18nText('alert_processing_failed') || 'Processing failed: ';
                    alert(processingFailedText + error.message);
                } finally {
                    document.getElementById('processBtn').disabled = false;
                }
            }
            
            async extractText() {
                const extractingText = getI18nText('progress_extracting_text') || 'Extracting text...';
                this.updateProgress(30, extractingText);
                
                const startPage = parseInt(document.getElementById('extractStartPage').value) || 1;
                const endPage = parseInt(document.getElementById('extractEndPage').value) || this.totalPages;
                const preserveFormatting = document.getElementById('preserveFormatting').checked;
                const removeBlankLines = document.getElementById('removeBlankLines').checked;
                const extractImages = document.getElementById('extractImages').checked;
                
                let extractedText = '';
                let imageLinks = [];
                
                try {
                    if (this.pdfDocument) {
                        // Actual PDF text extraction
                        const totalPages = Math.min(endPage, this.totalPages);
                        
                        for (let pageNum = startPage; pageNum <= totalPages; pageNum++) {
                            this.updateProgress(30 + (pageNum - startPage) / (totalPages - startPage + 1) * 60, 
                                             getI18nText('progress_extracting_page') ? getI18nText('progress_extracting_page').replace('{pageNum}', pageNum) : `Extracting page ${pageNum}...`);
                            
                            try {
                                const page = await this.pdfDocument.getPage(pageNum);
                                
                                // Extract text content
                                const textContent = await page.getTextContent();
                                let pageText = '';
                                
                                if (preserveFormatting) {
                                    // Preserve formatting: consider text position information
                                    let lastY = null;
                                    textContent.items.forEach(item => {
                                        if (lastY !== null && Math.abs(item.transform[5] - lastY) > 5) {
                                            pageText += '\n';
                                        }
                                        pageText += item.str;
                                        if (item.str.endsWith(' ') === false && item.hasEOL === false) {
                                            pageText += ' ';
                                        }
                                        lastY = item.transform[5];
                                    });
                                } else {
                                    // Simple text extraction
                                    pageText = textContent.items.map(item => item.str).join(' ');
                                }
                                
                                if (pageText.trim()) {
                                    if (extractedText && !extractedText.endsWith('\n\n')) {
                                        extractedText += '\n\n';
                                    }
                                    extractedText += `=== Page ${pageNum} ===\n`;
                                    extractedText += pageText.trim() + '\n';
                                }
                                
                                // Extract image information (if this option is selected)
                                if (extractImages) {
                                    try {
                                        const operatorList = await page.getOperatorList();
                                        let imageCount = 0;
                                        for (let i = 0; i < operatorList.fnArray.length; i++) {
                                            if (operatorList.fnArray[i] === pdfjsLib.OPS.paintImageXObject) {
                                                imageCount++;
                                                imageLinks.push(`[Image ${pageNum}-${imageCount}] Located on page ${pageNum}`);
                                            }
                                        }
                                    } catch (imgError) {
                                        console.warn('Failed to extract image information:', imgError);
                                    }
                                }
                                
                            } catch (pageError) {
                                console.error(`Page ${pageNum} extraction failed:`, pageError);
                                extractedText += `\n=== Page ${pageNum} ===\n[Page extraction failed: ${pageError.message}]\n`;
                            }
                        }
                    } else {
                        // Non-PDF documents use original logic
                        extractedText = this.documentContent || "Unable to extract text content";
                    }
                    
                    // ÂêéÂ§ÑÁêÜ
                    if (removeBlankLines && extractedText) {
                        extractedText = extractedText.replace(/\n\s*\n\s*\n/g, '\n\n');
                    }
                    
                    // Ê∑ªÂä†ÂõæÁâáÈìæÊé•‰ø°ÊÅØ
                    if (imageLinks.length > 0) {
                        const foundImagesText = getI18nText('text_found_images') || '=== Found Images ===';
                        extractedText += `\n\n${foundImagesText}\n`;
                        extractedText += imageLinks.join('\n');
                    }
                    
                    if (!extractedText.trim()) {
                        const noTextExtractedText = getI18nText('text_no_text_extracted') || 'Unable to extract text content. This may be an image-based PDF or scanned document.';
                        extractedText = noTextExtractedText;
                    }
                    
                    const extractionCompleteText = getI18nText('progress_extraction_complete') || 'Text extraction complete!';
                    this.updateProgress(100, extractionCompleteText);
                    
                } catch (error) {
                    console.error('ÊñáÊú¨ÊèêÂèñÂ§±Ë¥•:', error);
                    const extractionFailedText = getI18nText('text_extraction_failed') || 'Text extraction failed';
                    extractedText = `${extractionFailedText}: ${error.message}`;
                    const extractionFailedProgressText = getI18nText('progress_extraction_failed') || 'Extraction failed!';
                    this.updateProgress(100, extractionFailedProgressText);
                }
                
                // ÊòæÁ§∫ÊèêÂèñÁªìÊûú
                document.getElementById('extractedText').textContent = extractedText;
                document.getElementById('extractedTextArea').style.display = 'block';
            }
            
            async splitDocument() {
                const splittingText = getI18nText('progress_splitting_document') || 'Splitting document...';
                this.updateProgress(30, splittingText);
                
                const method = document.getElementById('splitMethod').value;
                let fileCount = 1;
                
                if (method === 'interval') {
                    const interval = parseInt(document.getElementById('splitInterval').value) || 10;
                    fileCount = Math.ceil(this.totalPages / interval);
                } else if (method === 'pages') {
                    const ranges = document.getElementById('pageRanges').value;
                    fileCount = ranges.split(',').length;
                }
                
                // Ê®°ÊãüÊñáÊ°£ÊãÜÂàÜ
                for (let i = 0; i < fileCount; i++) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    const creatingDocText = getI18nText('progress_creating_document') ? getI18nText('progress_creating_document').replace('{num}', i + 1) : `Creating document ${i + 1}...`;
                    this.updateProgress(30 + (i + 1) / fileCount * 60, creatingDocText);
                    
                    // ÂàõÂª∫Ê®°ÊãüÊñá‰ª∂
                    const fileName = this.documentFile.name.replace(/\.[^.]+$/, `_part${i + 1}.pdf`);
                    const simulatedPdfContent = getI18nText('text_simulated_pdf_content') || 'Simulated PDF content';
                    const blob = new Blob([simulatedPdfContent], { type: 'application/pdf' });
                    this.processedFiles.push(new File([blob], fileName, { type: 'application/pdf' }));
                }
                
                const splittingCompleteText = getI18nText('progress_splitting_complete') || 'Document splitting complete!';
                this.updateProgress(100, splittingCompleteText);
            }
            
            async mergeDocuments() {
                const mergingText = getI18nText('progress_merging_documents') || 'Merging documents...';
                this.updateProgress(30, mergingText);
                
                // Ê®°ÊãüÊñáÊ°£ÂêàÂπ∂
                for (let i = 0; i < this.mergeFiles.length; i++) {
                    await new Promise(resolve => setTimeout(resolve, 300));
                    const processingDocText = getI18nText('progress_processing_document') ? getI18nText('progress_processing_document').replace('{num}', i + 1) : `Processing document ${i + 1}...`;
                    this.updateProgress(30 + (i + 1) / this.mergeFiles.length * 60, processingDocText);
                }
                
                // ÂàõÂª∫ÂêàÂπ∂ÂêéÁöÑÊñá‰ª∂
                const mergedFileName = 'merged_document.pdf';
                const mergedPdfContent = getI18nText('text_merged_pdf_content') || 'Merged PDF content';
                const blob = new Blob([mergedPdfContent], { type: 'application/pdf' });
                this.processedFiles.push(new File([blob], mergedFileName, { type: 'application/pdf' }));
                
                const mergingCompleteText = getI18nText('progress_merging_complete') || 'Document merging complete!';
                this.updateProgress(100, mergingCompleteText);
            }
            
            async convertDocument() {
                const outputFormat = document.getElementById('outputFormat').value;
                const convertingToText = getI18nText('progress_converting_to') ? getI18nText('progress_converting_to').replace('{format}', outputFormat.toUpperCase()) : `Converting to ${outputFormat.toUpperCase()}...`;
                this.updateProgress(30, convertingToText);
                
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                let fileName = this.documentFile.name.replace(/\.[^.]+$/, '');
                let mimeType = 'application/octet-stream';
                let content = getI18nText('text_converted_document_content') || 'Converted document content';
                
                switch (outputFormat) {
                    case 'pdf':
                        fileName += '.pdf';
                        mimeType = 'application/pdf';
                        break;
                    case 'docx':
                        fileName += '.docx';
                        mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
                        break;
                    case 'txt':
                        fileName += '.txt';
                        mimeType = 'text/plain';
                        const convertedTextContent = getI18nText('text_converted_text_content') || 'Converted text content';
                        content = this.documentContent || convertedTextContent;
                        break;
                    case 'html':
                        fileName += '.html';
                        mimeType = 'text/html';
                        const convertedHtmlContent = getI18nText('text_converted_html_content') || 'Converted HTML content';
                        content = `<html><body><p>${this.documentContent || convertedHtmlContent}</p></body></html>`;
                        break;
                    case 'images':
                        // ÂØπ‰∫éÂõæÁâáÔºåÂàõÂª∫Â§ö‰∏™Êñá‰ª∂
                        for (let i = 1; i <= this.totalPages; i++) {
                            const imageFileName = `${fileName}_page${i}.jpg`;
                            const simulatedImageContent = getI18nText('text_simulated_image_content') || 'Simulated image content';
                            const blob = new Blob([simulatedImageContent], { type: 'image/jpeg' });
                            this.processedFiles.push(new File([blob], imageFileName, { type: 'image/jpeg' }));
                        }
                        const conversionCompleteText = getI18nText('progress_conversion_complete') || 'Format conversion complete!';
                        this.updateProgress(100, conversionCompleteText);
                        return;
                }
                
                const blob = new Blob([content], { type: mimeType });
                this.processedFiles.push(new File([blob], fileName, { type: mimeType }));
                
                const conversionCompleteText2 = getI18nText('progress_conversion_complete') || 'Format conversion complete!';
                this.updateProgress(100, conversionCompleteText2);
            }
            
            showResults(startTime) {
                const processingTime = ((Date.now() - startTime) / 1000).toFixed(1);
                const originalSize = this.documentFile.size;
                let totalResultSize = 0;
                
                this.processedFiles.forEach(file => {
                    totalResultSize += file.size;
                });
                
                document.getElementById('originalFileSize').textContent = this.formatFileSize(originalSize);
                document.getElementById('resultFileSize').textContent = this.formatFileSize(totalResultSize);
                document.getElementById('pageCount').textContent = this.totalPages;
                document.getElementById('processingTime').textContent = processingTime + 's';
                
                // ÊòæÁ§∫ÁªìÊûúÊñá‰ª∂ÂàóË°®
                this.updateResultFilesList();
                
                document.getElementById('resultSection').style.display = 'block';
                document.getElementById('resultSection').scrollIntoView({ behavior: 'smooth' });
            }
            
            updateResultFilesList() {
                const list = document.getElementById('resultFilesList');
                list.innerHTML = '';
                
                this.processedFiles.forEach((file, index) => {
                    const item = document.createElement('div');
                    item.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 12px; background: var(--bg-color-secondary); border-radius: 6px; margin-bottom: 10px;';
                    item.innerHTML = `
                        <div>
                            <strong>${file.name}</strong><br>
                            <small style="color: var(--text-secondary);">${this.formatFileSize(file.size)} ‚Ä¢ ${file.type}</small>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button onclick="documentProcessor.downloadFile(${index})" class="page-btn">${getI18nText('download') || 'Download'}</button>
                            <button onclick="documentProcessor.shareFile(${index})" class="page-btn">${getI18nText('share') || 'Share'}</button>
                        </div>
                    `;
                    list.appendChild(item);
                });
            }
            
            downloadFile(index) {
                const file = this.processedFiles[index];
                const url = URL.createObjectURL(file);
                const a = document.createElement('a');
                a.href = url;
                a.download = file.name;
                a.click();
                URL.revokeObjectURL(url);
            }
            
            shareFile(index) {
                const file = this.processedFiles[index];
                
                if (window.ui && window.ui.filesQueue) {
                    window.ui.filesQueue.push(file);
                    const fileAddedToShareText = getI18nText('alert_file_added_to_share') || 'added to share list!';
                    alert(`${file.name} ${fileAddedToShareText}`);
                } else {
                    const shareUnavailableText = getI18nText('alert_share_unavailable') || 'Share function is temporarily unavailable, please return to the share page first';
                    alert(shareUnavailableText);
                }
            }
            
            downloadAllFiles() {
                this.processedFiles.forEach((file, index) => {
                    setTimeout(() => this.downloadFile(index), index * 500);
                });
            }
            
            shareAllFiles() {
                if (window.ui && window.ui.filesQueue) {
                    this.processedFiles.forEach(file => {
                        window.ui.filesQueue.push(file);
                    });
                    const filesAddedToShareText = getI18nText('alert_files_added_to_share') || 'files added to share list!';
                    alert(`${this.processedFiles.length} ${filesAddedToShareText}`);
                } else {
                    const shareUnavailableText2 = getI18nText('alert_share_unavailable') || 'Share function is temporarily unavailable, please return to the share page first';
                    alert(shareUnavailableText2);
                }
            }
            
            copyExtractedText() {
                const text = document.getElementById('extractedText').textContent;
                navigator.clipboard.writeText(text).then(() => {
                    const textCopiedText = getI18nText('alert_text_copied') || 'Text copied to clipboard!';
                    alert(textCopiedText);
                }).catch(err => {
                    console.error('Â§çÂà∂Â§±Ë¥•:', err);
                    const copyFailedText = getI18nText('alert_copy_failed') || 'Copy failed, please manually select text to copy';
                    alert(copyFailedText);
                });
            }
            
            updateProgress(percent, text) {
                document.getElementById('progressFill').style.width = percent + '%';
                document.getElementById('progressText').textContent = text;
            }
            
            formatFileSize(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            resetSettings() {
                // ÈáçÁΩÆÊâÄÊúâËÆæÁΩÆÂà∞ÈªòËÆ§ÂÄº
                document.getElementById('extractStartPage').value = 1;
                document.getElementById('extractEndPage').value = this.totalPages;
                document.getElementById('splitMethod').value = 'pages';
                document.getElementById('splitInterval').value = 10;
                document.getElementById('outputFormat').value = 'pdf';
                // ... ÈáçÁΩÆÂÖ∂‰ªñËÆæÁΩÆ
                
                this.updateSplitSettings('pages');
                this.updateConvertSettings('pdf');
            }
            
            selectNewFile() {
                document.getElementById('fileInput').click();
            }
            
            processAnother() {
                document.getElementById('resultSection').style.display = 'none';
                document.getElementById('progressSection').style.display = 'none';
                document.getElementById('extractedTextArea').style.display = 'none';
                this.processedFiles = [];
                this.resetSettings();
            }
        }
        
        // ÂàùÂßãÂåñ
        let documentProcessor;
        document.addEventListener('DOMContentLoaded', () => {
            documentProcessor = new DocumentProcessor();
            // Initialize i18n after document processor
            if (window.DROPSHARE_I18N && typeof window.DROPSHARE_I18N.setLanguage === 'function') {
                // Force i18n refresh after DOM is ready
                setTimeout(() => {
                    const currentLang = window.DROPSHARE_I18N.getCurrentLanguage() || 'en';
                    window.DROPSHARE_I18N.setLanguage(currentLang);
                }, 100);
            }
        });
    </script>
    <!-- Share Integration -->
    <script src="device-selector.js"></script>
    <script src="add-share-integration.js"></script>
</body>
</html>